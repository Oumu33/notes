# CPU限制
1. 默认设置下，所有容器可以平等地使用 host CPU       资源并且没有限制。
2. Docker 可以通过 -c 或       --cpu-shares 设置容器使用 CPU 的权重。如果不指定，默认值为 1024。

与内存限额不同，通过 -c 设置的 cpu  share 并不是 CPU 资源的绝对数量，而是一个相对的权重值。某个容器最终能分配到的 CPU 资源取决于它的 cpu share 占所有容器 cpu  share 总和的比例。换句话说：通过 cpu share 可以设置容器使用 CPU 的优先级。

+ 比如在 host 中启动了两个容器：

docker run --name  "container_A" -c 1024 ubuntu

docker run --name  "container_B" -c 512 ubuntu

container_A 的 cpu  share 1024，是 container_B 的两倍。当两个容器都需要 CPU 资源时，container_A 可以得到的 CPU 是  container_B 的两倍。

+ 需要特别注意的是，这种按权重分配 CPU 只会发生在 CPU       资源紧张的情况下。如果 container_A 处于空闲状态，这时，为了充分利用 CPU 资源，container_B 也可以分配到全部可用的       CPU。
3. 继续用 progrium/stress 做实验。
+ 启动 container_A，cpu share 为       1024： 

[root@docker  ~]# docker run --name container_A -it -c 1024 progrium/stress --cpu 1

![](https://via.placeholder.com/800x600?text=Image+7c8acb60bac3855c)

--cpu 用来设置工作线程的数量。因为当前  host 只有 1 颗 CPU，所以一个工作线程就能将 CPU 压满。如果 host 有多颗 CPU，则需要相应增加 --cpu 的数量。

+ 启动 container_B，cpu share 为 512：       

[root@docker  ~]# docker run --name container_B -it -c 512 progrium/stress --cpu 1

![](https://via.placeholder.com/800x600?text=Image+6451218a8e7e2f66)

+ 在 host 中执行 top，查看容器对       CPU 的使用情况： 

container_A 消耗的 CPU 是  container_B 的两倍。

![](https://via.placeholder.com/800x600?text=Image+55b3edac77710a74)

+ 现在暂停 container_A： 

[root@docker  ~]# docker pause container_A

+ top 显示 container_B 在       container_A 空闲的情况下能够用满整颗 CPU： 

![](https://via.placeholder.com/800x600?text=Image+80685aab01a7eff7) 


