# 接口

> 来源: Web
> 创建时间: 2021-02-22T09:20:06+08:00
> 更新时间: 2026-01-11T09:25:01.530712+08:00
> 阅读量: 601 | 点赞: 0

---

> TypeScript 的核心原则之一是对值所具有的结构进行类型检查。我们使用接口（Interfaces）来定义对象的类型。
>
> 接口是对象的状态(属性)和行为(方法)的抽象(描述)
>

## 接口定义与使用
+ 接口类型的对象

多了或者少了属性是不允许的

可选属性: ?

只读属性: readonly

+ 需求: 创建人的对象, 需要对人的属性进行一定的约束

id是number类型, 必须有, 只读的

name是string类型, 必须有

age是number类型, 必须有

sex是string类型, 可以没有

```typescript
(() => {
  // 定义人的接口，改接口作为person对象的类型使用，限定该对象中的属性数据
  interface IPerson {
    // id是只读属性
    readonly id: number
    name: string
    age: number
    // sex可以不存在
    sex?: string
  }
  // 定义一个对象，类型为前面定义的接口IPerson
  const person1: IPerson = {
    id: 1,
    name: 'tom',
    age: 20,
    sex: '男'
  }
  console.log(person1)
})()
// 执行结果
// {id: 1, name: "tom", age: 20, sex: "男"}
```

## 函数类型
> 为了使用接口表示函数类型，需要给接口定义一个调用签名
>
> 它就像是一个只有参数列表和返回值类型的函数定义，参数列表中的每个参数都需要名字和类型
>

```typescript
(() => {
  // 定义一个接口，作为函数的类型使用
  interface SearchFunc {
    (source: string, subString: string): boolean
  }
  // 定义一个函数，类型为前面定义的接口IPerson
  const mySearch: SearchFunc = function (source: string, sub: string): boolean {
    // 在source字符串中查找是否存在sub字符串
    return source.search(sub) > -1
  }
  // 调用函数
  console.log(mySearch('abcd', 'bc'))
})()
// 输出结果
// true
```

## 类类型
> 与 C# 或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。
>
> 接口中定义的方法，在类中都要实现
>

### 类实现接口
```typescript
(() => {
  // 定义一个接口，作为类的类型使用
  interface IFly {
    // 该方法没有任何的实现（方法中什么都没有）
    fly()
  }

  // 定义一个类，这个类的类型就是上面定义的接口（IFly接口约束了当前这个类）
  class Person implements IFly {
    // 实现接口中的方法
    fly() {
      console.log('起飞了')
    }
  }

  // 实例化对象
  const person = new Person()
  person.fly()
})()
// 输出结果
// 起飞了
```

### 一个类可以实现多个接口
```typescript
(() => {
  // 定义一个接口，作为类的类型使用
  interface IFly {
    // 该方法没有任何的实现（方法中什么都没有）
    fly()
  }

// 定义另一个接口，作为类的类型使用
  interface ISay {
    // 该方法没有任何的实现（方法中什么都没有）
    say()
  }

  // 定义一个类，这个类的类型就是上面定义的接口（IFly接口约束了当前这个类）
  class Person implements IFly, ISay {
    // 实现接口中的方法
    fly() {
      console.log('起飞了')
    }

    say() {
      console.log('说话了')
    }
  }

  // 实例化对象
  const person = new Person()
  person.fly()
  person.say()
})()
// 输出结果
// 起飞了
// 说话了
```

### 接口继承接口
> 和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。``
>

```typescript
(() => {
  // 定义一个接口，作为类的类型使用
  interface IFly {
    // 该方法没有任何的实现（方法中什么都没有）
    fly()
  }

  // 定义另一个接口，作为类的类型使用
  interface ISay {
    // 该方法没有任何的实现（方法中什么都没有）
    say()
  }

  // 定义一个接口，它继承了前面两个接口
  interface IFlyAndISay extends IFly, ISay {
  }

  // 定义一个类，这个类的类型就是上面定义的继承接口
  class Person implements IFlyAndISay {
    // 实现接口中的方法
    fly() {
      console.log('起飞了')
    }

    say() {
      console.log('说话了')
    }
  }

  // 实例化对象
  const person = new Person()
  person.fly()
  person.say()
})()
// 输出结果
// 起飞了
// 说话了
```


