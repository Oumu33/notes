# 主从复制与主从切换
# 主从同步
## 环境准备
需要2台安装了Mysql的服务器，服务器配置如下：

| 操作系统类型 | IP | 主机名 | mysql版本 | 主从类型 |
| --- | --- | --- | --- | --- |
| rockylinux8.10 | 192.168.10.201 | mysql-1 | 8.4.4 | 主 |
| rockylinux8.10 | 192.168.10.202 | mysql-2 | 8.4.4 | 从 |


## mysql 部署
具体可参考文档[https://www.cuiliangblog.cn/detail/section/31461021](https://www.cuiliangblog.cn/detail/section/31461021)

## 主节点配置
注1：我当前mysql数据目录是/data/mysql，你们需根据自己实际的数据库数据目录去进行修改。

> 主从节点配置的差异：由于后续需要演示主从切换，所以无论是主从节点，都需要提前开启binlog和relaylog。故而这里主从配置基本一致，具体配置选项差异只有：server_id、read-only选项
>

编辑/etc/my.conf文件，在[mysqld]下添加以下内容

```bash
[root@mysql-1 ~]# vim /etc/my.cnf
#==================== 主从同步配置=========================
#节点id编号，各个mysql的server_id需要唯一
server_id=1
#[可选]指定binlog和binglog index的文件名
log_bin=/data/mysql/binlog
log_bin_index=/data/mysql/binlog.index
#[可选]启用中继日志
relay-log=/data/mysql/mysql-relay
#[可选] 单个binlog最大的文件大小，默认是1G
max_binlog_size=500M
#[可选]设置binlog格式.STATEMENT,row,mixed
binlog_format=row
#[可选]0（默认）表示读写（主机），1表示只读（从机）
read-only=0
#[可选]设置日志文件保留的时长，单位是秒(默认不删除文件)
binlog_expire_logs_seconds=604800
#[可选]设置不要复制的数据库
#binlog-ignore-db=test
#[可选]设置需要复制的数据库,默认全部记录。比如：binlog-do-db=atguigu_master_slave
#binlog-do-db=需要复制的主数据库名字
```

修改配置后重启数据库:

```plain
systemctl restart mysqld
```

## 从节点配置
> 主从节点配置的差异：由于后续需要演示主从切换，所以无论是主从节点，都需要提前开启binlog和relaylog。故而这里主从配置基本一致，具体配置选项差异只有：server_id、read-only选项
>

编辑/etc/my.conf文件，在[mysqld]下配置添加以下内容

```bash
[root@mysql-1 ~]# vim /etc/my.cnf
#节点id编号，各个mysql的server_id需要唯一
server_id=2
#指定binlog和binglog index的文件名
log_bin=/data/mysql/binlog
log_bin_index=/data/mysql/binlog.index
#[可选]启用中继日志
relay-log=/data/mysql/mysql-relay
#[可选] 单个binlog最大的文件大小，默认是1G
max_binlog_size=500M
#[可选]设置binlog格式.STATEMENT,row,mixed
binlog_format=row
#[可选]0（默认）表示读写（主机），1表示只读（从机）
read-only=1
#[可选]设置日志文件保留的时长，单位是秒(默认不删除文件)
binlog_expire_logs_seconds=6000
#[可选]设置不要复制的数据库
#binlog-ignore-db=test
#[可选]设置需要复制的数据库,默认全部记录。比如：binlog-do-db=atguigu_master_slave
#binlog-do-db=需要复制的主数据库名字
```

修改配置后重启数据库:

```plain
systemctl restart mysqld
```

## 创建用于主从同步的用户
主节点进行以下操作：

```bash
mysql> CREATE USER 'replication_user'@'192.168.10.202' IDENTIFIED BY '123.com';
Query OK, 0 rows affected (0.00 sec)

mysql> GRANT REPLICATION SLAVE ON *.* TO 'replication_user'@'192.168.10.202';
Query OK, 0 rows affected (0.00 sec)

mysql> FLUSH PRIVILEGES;
Query OK, 0 rows affected (0.00 sec)
```

## 开启主从同步
1. 查看主节点binlog执行位置：

> 如果是 8.0.21 以及以后版本：
>

```bash
mysql> SHOW BINARY LOG STATUS;
+---------------+----------+--------------+------------------+-------------------+
| File          | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+---------------+----------+--------------+------------------+-------------------+
| binlog.000007 |     1593 |              |                  |                   |
+---------------+----------+--------------+------------------+-------------------+
1 row in set (0.00 sec)
```

 记录输出中的 `File` 和 `Position`，稍后在从服务器配置中会用到。  

> 如果是 8.0.20 以及以前版本：
>

```bash
mysql> SHOW MASTER STATUS;
+---------------+----------+--------------+------------------+-------------------+
| File          | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+---------------+----------+--------------+------------------+-------------------+
| binlog.000008 |      898 |              |                  |                   |
+---------------+----------+--------------+------------------+-------------------+
1 row in set (0.00 sec)
```

2. 从节点开启主节点同步操作：

> 如果是  8.0.21 以及以后版本：
>

```bash
CHANGE REPLICATION SOURCE TO
  SOURCE_HOST='192.168.10.201',
  SOURCE_USER='replication_user',
  SOURCE_PASSWORD='123.com',
  SOURCE_LOG_FILE='binlog.000007',
  SOURCE_LOG_POS=1593,
  GET_SOURCE_PUBLIC_KEY=1;
```

> 如果是8.0.20 以及以前版本：
>

```bash
CHANGE MASTER TO
    MASTER_HOST='192.168.10.201',
    MASTER_USER='replication_user',
    MASTER_PASSWORD='123.com',
    MASTER_LOG_FILE='binlog.000008',
    MASTER_LOG_POS=898;
```

3. 启动复制进程

在从服务器的 MySQL 控制台中，执行：

> 如果是  8.0.21 以及以后版本：
>

```bash
mysql> START REPLICA;
Query OK, 0 rows affected (0.04 sec)
```

> 如果是8.0.20 以及以前版本：
>

```bash
mysql> START SLAVE;
Query OK, 0 rows affected (0.00 sec)
```

4. 检查复制状态

执行以下命令以检查复制状态：

> 如果是  8.0.21 以及以后版本：
>

```bash
mysql> SHOW REPLICA STATUS\G;
*************************** 1. row ***************************
             Replica_IO_State: Waiting for source to send event
                  Source_Host: 192.168.10.201
                  Source_User: replication_user
                  Source_Port: 3306
                Connect_Retry: 60
              Source_Log_File: binlog.000007
          Read_Source_Log_Pos: 1593
               Relay_Log_File: mysql-relay.000002
                Relay_Log_Pos: 325
        Relay_Source_Log_File: binlog.000007
           Replica_IO_Running: Yes
          Replica_SQL_Running: Yes
```

 确保 `Replica_IO_Running` 和 `Replica_SQL_Running` 都显示为 `Yes`，这表示主从复制已成功配置。  

> 如果是8.0.20 以及以前版本：
>

```bash
mysql> SHOW SLAVE STATUS\G;
*************************** 1. row ***************************
               Slave_IO_State: Connecting to master
                  Master_Host: 192.168.10.201
                  Master_User: replication_user
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: binlog.000008
          Read_Master_Log_Pos: 898
               Relay_Log_File: mysql-relay.000001
                Relay_Log_Pos: 4
        Relay_Master_Log_File: binlog.000008
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
```

## 主从同步验证
在主节点上建库、建表、插入表数据：

```bash
# 创建数据库
mysql> create database test_db;
Query OK, 1 row affected (0.00 sec)
# 查看数据库
mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| test_db            |
+--------------------+
# 切换数据库
mysql> use test_db;
Database changed
# 创建表
mysql> CREATE TABLE `t_test` (
 `id` int(11) NOT NULL,
 `age` int(11) DEFAULT NULL,
 `score` int(11) DEFAULT NULL,
 PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 ROW_FORMAT=DYNAMIC;
Query OK, 0 rows affected, 3 warnings (0.01 sec)

# 插入表数据
mysql> INSERT INTO `t_test` VALUES (1, 2, 1);
Query OK, 1 row affected (0.01 sec)
# 查看表
mysql> show tables;
+-------------------+
| Tables_in_test_db |
+-------------------+
| t_test            |
+-------------------+
1 row in set (0.00 sec)
# 查看表数据
mysql> select * from t_test;
+-----+------+-------+
| id  | age  | score |
+-----+------+-------+
|   1 |    2 |     1 |
+-----+------+-------+
2 rows in set (0.00 sec)
```

检查从节点是否也都同步成功：

```bash
mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| test_db            |
+--------------------+
5 rows in set (0.00 sec)
# 切换数据库
mysql> use test_db;
Database changed
# 查看表
mysql> show tables;
+-------------------+
| Tables_in_test_db |
+-------------------+
| t_test            |
+-------------------+
1 row in set (0.00 sec)
# 查询表数据
mysql> select * from t_test;
+-----+------+-------+
| id  | age  | score |
+-----+------+-------+
|   1 |    2 |     1 |
+-----+------+-------+
2 rows in set (0.00 sec)
```

至此，主从同步就完成

# 主从手动切换
如果主服务器（Primary）发生故障，需要手动提升从服务器（Replica）为主服务器。  

## 环境准备
| 操作系统类型 | IP | 主机名 | mysql版本 | 切换前 | 切换后 |
| --- | --- | --- | --- | --- | --- |
| rockylinux8.10 | 192.168.10.201 | mysql-1 | 8.4.4 | 主 | 从 |
| rockylinux8.10 | 192.168.10.202 | mysql-2 | 8.4.4 | 从 | 主 |


## 主节点设置只读模式
主节点设置只读模式，避免进行主从切换过程中还有写操作，导致切换后主从数据不一致问题。

> 用命令设置的只读模式是临时的，重启后失效。如果想让mysql重启后也能生效，可以将read_only相关选项配置到my.conf文件里面。
>

```bash
# 查看只读相关配置
mysql> show VARIABLES like '%read_only%';
+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| innodb_read_only      | OFF   |
| read_only             | OFF   |
| super_read_only       | OFF   |
| transaction_read_only | OFF   |
+-----------------------+-------+
# 开启全局只读(包括普通用户、超级管理员root也都不能写)
mysql> set global super_read_only='on';
Query OK, 0 rows affected (0.00 sec)
# 查看只读相关配置
mysql> show VARIABLES like '%read_only%';
+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| innodb_read_only      | OFF   |
| read_only             | ON    |
| super_read_only       | ON    |
| transaction_read_only | OFF   |
+-----------------------+-------+
4 rows in set (0.00 sec)
```

## 从节点检查主从数据
```bash
mysql> SHOW REPLICA STATUS\G;
*************************** 1. row ***************************
             Replica_IO_State: Waiting for source to send event
                  Source_Host: 192.168.10.201
                  Source_User: replication_user
                  Source_Port: 3306
                Connect_Retry: 60
              Source_Log_File: binlog.000007
          Read_Source_Log_Pos: 2443
               Relay_Log_File: mysql-relay.000002
                Relay_Log_Pos: 1175
        Relay_Source_Log_File: binlog.000007
           Replica_IO_Running: Yes
          Replica_SQL_Running: Yes
```

Slave_IO_Running和Slave_SQL_Running都为true代表主、从是正常同步

## 停止并重置从节点
```bash
# 停止从节点
mysql> STOP REPLICA;
Query OK, 0 rows affected (0.00 sec)
# 重置掉从节点的相关主从同步信息，同时将relaylog文件进行删除重置
mysql> RESET REPLICA ALL;
Query OK, 0 rows affected (0.01 sec)
```

## 关闭原从节点的只读配置
> 用命令设置的只读模式是临时的，重启后失效。如果想让mysql重启后也能生效，可以将read_only相关选项配置到my.conf文件里面或者从my.conf进行删除，以为默认就是只读关闭。
>

```bash
#查看只读相关配置
mysql> show VARIABLES like '%read_only%';
+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| innodb_read_only      | OFF   |
| read_only             | ON    |
| super_read_only       | OFF   |
| transaction_read_only | OFF   |
+-----------------------+-------+
#关闭全局只读(让超级管理员root能进行写操作)
set global super_read_only='off';
#关闭全局只读(让普通用户也能写操作)
set global read_only='off';
#查看只读相关配置
mysql> show VARIABLES like '%read_only%';
+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| innodb_read_only      | OFF   |
| read_only             | OFF   |
| super_read_only       | OFF   |
| transaction_read_only | OFF   |
+-----------------------+-------+
4 rows in set (0.00 sec)
```

## 主从切换
> 进行主从同步的过程不要任何写操作，避免导致切换后主从数据不一致。
>

1. 查看原从节点的最新日志以及偏移量。

```plain
mysql> SHOW BINARY LOG STATUS;
+---------------+----------+--------------+------------------+-------------------+
| File          | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+---------------+----------+--------------+------------------+-------------------+
| binlog.000005 |     1888 |              |                  |                   |
+---------------+----------+--------------+------------------+-------------------+
1 row in set (0.00 sec)
```

2. 主从节点创建用于主从同步的用户

```bash
mysql> CREATE USER 'replication_user'@'192.168.10.201' IDENTIFIED BY '123.com';
Query OK, 0 rows affected (0.00 sec)

mysql> GRANT REPLICATION SLAVE ON *.* TO 'replication_user'@'192.168.10.201';
Query OK, 0 rows affected (0.00 sec)

mysql> FLUSH PRIVILEGES;
Query OK, 0 rows affected (0.00 sec)
```

3. 将原主节点设置为原从节点

```bash
# 设置主节点信息
CHANGE REPLICATION SOURCE TO
  SOURCE_HOST='192.168.10.202',
  SOURCE_USER='replication_user',
  SOURCE_PASSWORD='123.com',
  SOURCE_LOG_FILE='binlog.000005',
  SOURCE_LOG_POS=1888,
  GET_SOURCE_PUBLIC_KEY=1;
# 开启slave
mysql> START REPLICA;
Query OK, 0 rows affected (0.05 sec)
# 查看主从同步信息
mysql> SHOW REPLICA STATUS\G;
*************************** 1. row ***************************
             Replica_IO_State: Waiting for source to send event
                  Source_Host: 192.168.10.202
                  Source_User: replication_user
                  Source_Port: 3306
                Connect_Retry: 60
              Source_Log_File: binlog.000005
          Read_Source_Log_Pos: 2650
               Relay_Log_File: mysql-relay.000002
                Relay_Log_Pos: 1087
        Relay_Source_Log_File: binlog.000005
           Replica_IO_Running: Yes
          Replica_SQL_Running: Yes
```

注：当Slave_IO_Running和Slave_SQL_Running都为Yes时，代表切换成功。

## 验证
1. 在新主节点插入表数据

```bash
mysql> INSERT INTO `t_test` VALUES (300, 3, 1);
Query OK, 1 row affected (0.00 sec)

mysql> select * from t_test;
+-----+------+-------+
| id  | age  | score |
+-----+------+-------+
|   1 |    2 |     1 |
| 300 |    3 |     1 |
+-----+------+-------+
2 rows in set (0.00 sec)
```

2. 在新从节点查看表数据，发现在新主节点插入的数据已经自动同步到新从节点上了。

```bash
mysql> select * from t_test;
+-----+------+-------+
| id  | age  | score |
+-----+------+-------+
|   1 |    2 |     1 |
| 300 |    3 |     1 |
+-----+------+-------+
2 rows in set (0.00 sec)
```

# 主从不一致处理
mysql replication 中slave机器上有两个关键的进程，必须都运行才可以。

一个是slave_sql_running，

一个是Slave_IO_Running，

## Replica_IO_Running异常
通常是由于指向主库 binlog 日志文件异常导致，重新指向最新的日志既可。

从库查看同步状态

```bash
mysql> SHOW REPLICA STATUS\G;
*************************** 1. row ***************************
             Replica_IO_State: 
                  Source_Host: 192.168.10.201
                  Source_User: replication_user
                  Source_Port: 3306
                Connect_Retry: 60
              Source_Log_File: binlog.000004
          Read_Source_Log_Pos: 1745
               Relay_Log_File: mysql-relay.000002
                Relay_Log_Pos: 1171
        Relay_Source_Log_File: binlog.000004
           Replica_IO_Running: No
          Replica_SQL_Running: Yes
```

主库查看 binlog 日志信息

```bash
mysql> SHOW BINARY LOG STATUS;
+---------------+----------+--------------+------------------+-------------------+
| File          | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+---------------+----------+--------------+------------------+-------------------+
| binlog.000006 |      158 |              |                  |                   |
+---------------+----------+--------------+------------------+-------------------+
1 row in set (0.00 sec)
```

从库修改同步配置

```bash
mysql> RESET REPLICA ALL;
Query OK, 0 rows affected (0.00 sec)

mysql> CHANGE REPLICATION SOURCE TO
  SOURCE_HOST='192.168.10.201',
  SOURCE_USER='replication_user',
  SOURCE_PASSWORD='123.com',
  SOURCE_LOG_FILE='binlog.000006',
  SOURCE_LOG_POS=158,
  GET_SOURCE_PUBLIC_KEY=1;
Query OK, 0 rows affected, 2 warnings (0.01 sec)

mysql> START REPLICA;
Query OK, 0 rows affected (0.04 sec)

mysql> SHOW REPLICA STATUS\G;
*************************** 1. row ***************************
             Replica_IO_State: Waiting for source to send event
                  Source_Host: 192.168.10.201
                  Source_User: replication_user
                  Source_Port: 3306
                Connect_Retry: 60
              Source_Log_File: binlog.000006
          Read_Source_Log_Pos: 158
               Relay_Log_File: mysql-relay.000002
                Relay_Log_Pos: 325
        Relay_Source_Log_File: binlog.000006
           Replica_IO_Running: Yes
          Replica_SQL_Running: Yes
```

## Replica_SQL_Running 异常
```bash
mysql> stop slave;                                                      
mysql> SET GLOBAL SQL_SLAVE_SKIP_COUNTER=1; START SLAVE;            
mysql> start slave;                                                      
mysql> show slave status\G  
```


