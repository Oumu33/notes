# ä»é›¶åˆ°ä¸€æ‰‹åŠ¨æ­å»ºRAGç³»ç»Ÿ

> æ¥æº: AIOPS
> åˆ›å»ºæ—¶é—´: 2025-09-03T11:03:54+08:00
> æ›´æ–°æ—¶é—´: 2026-01-11T09:44:55.629081+08:00
> é˜…è¯»é‡: 1221 | ç‚¹èµ: 1

---

# <font style="color:rgb(0, 0, 0);">é¡¹ç›®ä»‹ç»</font>
## é¡¹ç›®èƒŒæ™¯
éšç€ç¾å›¢ä¸šåŠ¡çš„ä¸æ–­æ‰©å±•ï¼Œå®¢æœäººå‘˜éœ€è¦åº”å¯¹æµ·é‡çš„ç”¨æˆ·å’¨è¯¢ï¼ŒåŒ…æ‹¬è®¢å•é—®é¢˜ã€é€€æ¬¾æµç¨‹ã€é…é€å¼‚å¸¸ã€ä¼˜æƒ æ”¿ç­–ç­‰ã€‚ä¼ ç»Ÿçš„çŸ¥è¯†åº“å®¢æœç³»ç»Ÿä¾èµ–è§„åˆ™åŒ¹é…ï¼Œå›ç­”åƒµç¡¬ï¼Œéš¾ä»¥åŠæ—¶è¦†ç›–æœ€æ–°çš„ä¸šåŠ¡è§„åˆ™ã€‚

## é¡¹ç›®åŠŸèƒ½
ä¸ºæå‡å®¢æˆ·ä½“éªŒå’Œå®¢æœæ•ˆç‡ï¼Œæœ¬é¡¹ç›®åŸºäº RAGï¼ˆRetrieval-Augmented Generationï¼Œæ£€ç´¢å¢å¼ºç”Ÿæˆï¼‰ æŠ€æœ¯æ„å»ºæ™ºèƒ½å®¢æœé—®ç­”ç³»ç»Ÿï¼Œå°†ç¾å›¢å†…éƒ¨æ–‡æ¡£çŸ¥è¯†ä¸å¤§è¯­è¨€æ¨¡å‹ç»“åˆï¼Œå®ç°æ›´æ™ºèƒ½ã€æ›´å‡†ç¡®çš„è‡ªåŠ¨åŒ–ç­”å¤ã€‚  

# é¡¹ç›®å®ç°
## æ–‡æ¡£æ”¶é›†
æ”¶é›†ç¾å›¢å®¢æœç›¸å…³çŸ¥è¯†æ–‡æ¡£ï¼Œä¾‹å¦‚ï¼š

+ ä¸šåŠ¡æ‰‹å†Œï¼ˆé€€æ¬¾è§„åˆ™ã€è®¢å•å¤„ç†æµç¨‹ï¼‰
+ å¸¸è§é—®é¢˜ FAQ
+ å†…éƒ¨å®¢æœçŸ¥è¯†åº“
+ å®æ—¶æ›´æ–°çš„è¿è¥å…¬å‘Š

ä»¥ç¾å›¢å¤–å–å¸¸è§é—®é¢˜ä¸ºä¾‹ï¼Œæ–‡æ¡£åœ°å€ï¼š[https://waimai.meituan.com/help/faq](https://waimai.meituan.com/help/faq)ï¼Œæˆ‘ä»¬é€šè¿‡playwright å·¥å…·çˆ¬è™«è·å–é¡µé¢æ•°æ®å¹¶å†™å…¥æœ¬åœ° txt æ–‡ä»¶ä¸­ã€‚

å®‰è£…ä¾èµ–åŒ…

```python
# å®‰è£…æµè§ˆå™¨æ’ä»¶åº“
pip install playwright chromium
playwright install
# å®‰è£…æµè§ˆå™¨ä¸­æ–‡ä¾èµ–
sudo apt update && sudo apt install fonts-wqy-zenhei fonts-wqy-microhei -y
```

ä»£ç å¦‚ä¸‹ï¼š

```python
from playwright.sync_api import sync_playwright

def collect_faq(url):
    """
    æ”¶é›†æŒ‡å®šURLé¡µé¢ä¸­çš„FAQå†…å®¹
    
    å‚æ•°:
        url (str): ç›®æ ‡ç½‘é¡µURLåœ°å€
        
    è¿”å›:
        str: æå–çš„FAQæ–‡æœ¬å†…å®¹
    """
    # å¯åŠ¨Playwrightæµè§ˆå™¨è‡ªåŠ¨åŒ–å·¥å…·
    with sync_playwright() as p:
        # å¯åŠ¨Chromiumæµè§ˆå™¨ï¼Œè®¾ç½®ä¸ºéæ— å¤´æ¨¡å¼å¹¶æŒ‡å®šä¸­æ–‡è¯­è¨€
        browser = p.chromium.launch(
            headless=False,
            args=['--lang=zh-CN']  # æµè§ˆå™¨è¯­è¨€
        )
        # åˆ›å»ºæ–°é¡µé¢ï¼Œé…ç½®ä¸­æ–‡ç¯å¢ƒ
        page = browser.new_page(
            locale='zh-CN',  # é¡µé¢ locale
            user_agent=(
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
                "AppleWebKit/537.36 (KHTML, like Gecko) "
                "Chrome/139.0.0.0 Safari/537.36 Edg/139.0.0.0"
            ),
            extra_http_headers={
                "Accept-Language": "zh-CN,zh;q=0.9"
            }
        )
        # è®¿é—®ç›®æ ‡URLå¹¶ç­‰å¾…é¡µé¢åŠ è½½å®Œæˆ
        page.goto(url, timeout=30_000)
        page.wait_for_load_state("networkidle")

        # æå–FAQåˆ—è¡¨åŒºåŸŸçš„æ–‡æœ¬å†…å®¹
        raw_text = page.locator("#faq-list").first.text_content()
        browser.close()
        return raw_text

def save_faq(cleaned_text:str, output_file:str):
    """
    å°†FAQæ–‡æœ¬å†…å®¹ä¿å­˜åˆ°æŒ‡å®šæ–‡ä»¶
    
    å‚æ•°:
        cleaned_text (str): è¦ä¿å­˜çš„FAQæ–‡æœ¬å†…å®¹
        output_file (str): è¾“å‡ºæ–‡ä»¶è·¯å¾„
    """
    # å†™å…¥æ–‡ä»¶
    with open(output_file, "w", encoding="utf-8") as f:
        f.write(cleaned_text)

    print(f"FAQ å·²ä¿å­˜åˆ° {output_file}")

if __name__ == "__main__":
    cleaned_text = collect_faq(url="https://waimai.meituan.com/help/faq")
    output_file = "faq.txt"
    save_faq(cleaned_text, output_file)
```

æ‰§è¡Œç»“æœå¦‚ä¸‹ï¼š

```bash
# head -n 20 faq.txt           

      
        
          åœ¨çº¿æ”¯ä»˜é—®é¢˜
          
        
        
          
            Qï¼šåœ¨çº¿æ”¯ä»˜å–æ¶ˆè®¢å•åé’±æ€ä¹ˆè¿”è¿˜ï¼Ÿ
            
              è®¢å•å–æ¶ˆåï¼Œæ¬¾é¡¹ä¼šåœ¨ä¸€ä¸ªå·¥ä½œæ—¥å†…ï¼Œç›´æ¥è¿”è¿˜åˆ°æ‚¨çš„ç¾å›¢è´¦æˆ·ä½™é¢ã€‚
            
          
        
        
          
            Qï¼šæ€ä¹ˆæŸ¥çœ‹é€€æ¬¾æ˜¯å¦æˆåŠŸï¼Ÿ
            
              é€€æ¬¾ä¼šåœ¨ä¸€ä¸ªå·¥ä½œæ—¥ä¹‹å†…åˆ°ç¾å›¢è´¦æˆ·ä½™é¢ï¼Œå¯åœ¨â€œè´¦å·ç®¡ç†â€”â€”æˆ‘çš„è´¦å·â€ä¸­æŸ¥çœ‹æ˜¯å¦åˆ°è´¦
```

## æ–‡æ¡£å¤„ç†
æˆ‘ä»¬å·²ç»çˆ¬å–äº† FAQ æ–‡æ¡£ï¼Œæ¥ä¸‹æ¥å°±éœ€è¦å¯¹æ”¶é›†åˆ°çš„æ–‡æ¡£è¿›è¡Œç»Ÿä¸€å¤„ç†ï¼Œå†…å®¹åŒ…æ‹¬ï¼š

+ æ–‡æœ¬æ¸…æ´—ï¼ˆå»é™¤ HTML æ ‡ç­¾ã€æ— å…³å­—ç¬¦ï¼‰
+ åˆ†æ®µåˆ‡åˆ†ï¼ˆæŒ‰è§„åˆ™æˆ–è¯­ä¹‰å°†æ–‡æ¡£æ‹†åˆ†æˆå°ç‰‡æ®µï¼Œä¾¿äºæ£€ç´¢ï¼‰
+ å…ƒæ•°æ®æ ‡æ³¨ï¼ˆæ¥æºã€æ—¶é—´ã€ä¸šåŠ¡ç±»åˆ«ç­‰ï¼‰ã€‚

ä»£ç å¦‚ä¸‹ï¼š

```python
import re
import json
from pathlib import Path
from datetime import datetime, timezone

def clean_text(text: str) -> str:
    """
    æ¸…æ´—æ–‡æœ¬å†…å®¹ï¼Œå»é™¤HTMLæ ‡ç­¾å’Œå¤šä½™ç©ºæ ¼åŠæ— æ•ˆå­—ç¬¦ã€‚

    å‚æ•°:
        text (str): éœ€è¦æ¸…æ´—çš„åŸå§‹æ–‡æœ¬ã€‚

    è¿”å›:
        str: æ¸…æ´—åçš„æ–‡æœ¬å†…å®¹ã€‚
    """
    # å»æ‰ HTML æ ‡ç­¾ï¼ˆå¦‚æœæœ‰æ®‹ç•™ï¼‰
    text = re.sub(r"<.*?>", "", text)
    # å»æ‰å¤šä½™ç©ºæ ¼å¹¶è¿‡æ»¤ç©ºè¡Œ
    lines = [line.strip() for line in text.splitlines() if line.strip()]
    return "\n".join(lines)

def split_faq(text: str):
    """
    æ ¹æ® Q/A è§„åˆ™å°†FAQæ–‡æœ¬åˆ‡åˆ†ä¸ºé—®é¢˜å’Œç­”æ¡ˆå¯¹ã€‚

    å‚æ•°:
        text (str): åŒ…å«FAQå†…å®¹çš„æ–‡æœ¬å­—ç¬¦ä¸²ã€‚

    è¿”å›:
        list[dict]: æ¯ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªåŒ…å«"question"å’Œ"answer"é”®çš„å­—å…¸ã€‚
    """
    # æŒ‰ Qï¼š æˆ– Q: åˆ†å‰²æ–‡æœ¬
    parts = re.split(r"(?:^|\n)Q[:ï¼š]", text)
    qa_pairs = []
    for part in parts:
        part = part.strip()
        if not part:
            continue
        # å°†ç¬¬ä¸€è¡Œä½œä¸ºé—®é¢˜ï¼Œå…¶ä½™éƒ¨åˆ†ä½œä¸ºç­”æ¡ˆ
        lines = part.splitlines()
        question = lines[0]
        answer = "\n".join(lines[1:]) if len(lines) > 1 else ""
        qa_pairs.append({
            "question": question,
            "answer": answer
        })
    return qa_pairs

def process_faq(input_file: str, output_file: str, source_url: str, category="FAQ"):
    """
    å¤„ç†FAQæ–‡æœ¬æ–‡ä»¶ï¼Œæ¸…æ´—ã€åˆ†å‰²å¹¶æ·»åŠ å…ƒæ•°æ®åä¿å­˜ä¸ºJSONæ ¼å¼ã€‚

    å‚æ•°:
        input_file (str): è¾“å…¥çš„åŸå§‹FAQæ–‡æœ¬æ–‡ä»¶è·¯å¾„ã€‚
        output_file (str): è¾“å‡ºå¤„ç†åçš„JSONæ–‡ä»¶è·¯å¾„ã€‚
        source_url (str): æ•°æ®æ¥æºURLã€‚
        category (str): FAQåˆ†ç±»ï¼Œé»˜è®¤ä¸º"FAQ"ã€‚

    è¿”å›:
        None
    """
    raw_text = Path(input_file).read_text(encoding="utf-8")
    cleaned_text = clean_text(raw_text)
    qa_pairs = split_faq(cleaned_text)

    # æ·»åŠ å…ƒæ•°æ®ä¿¡æ¯
    now = datetime.now(timezone.utc).isoformat()
    processed = []
    for qa in qa_pairs:
        processed.append({
            "question": qa["question"],
            "answer": qa["answer"],
            "metadata": {
                "source": source_url,
                "category": category,
                "crawl_time": now
            }
        })

    Path(output_file).write_text(
        json.dumps(processed, ensure_ascii=False, indent=2),
        encoding="utf-8"
    )
    print(f"âœ… å·²å¤„ç† {len(processed)} æ¡ FAQï¼Œç»“æœä¿å­˜åˆ° {output_file}")

if __name__ == "__main__":
    process_faq(
        input_file="faq.txt",
        output_file="faq_processed.json",
        source_url="https://waimai.meituan.com/help/faq",
        category="æ”¯ä»˜é—®é¢˜"
    )
```

æ‰§è¡Œåçš„æ•ˆæœå¦‚ä¸‹

```python
# head -n 20 faq_processed.json
[
  {
    "question": "åœ¨çº¿æ”¯ä»˜é—®é¢˜",
    "answer": "",
    "metadata": {
      "source": "https://waimai.meituan.com/help/faq",
      "category": "æ”¯ä»˜é—®é¢˜",
      "crawl_time": "2025-09-04T02:38:28.261319+00:00"
    }
  },
  {
    "question": "åœ¨çº¿æ”¯ä»˜å–æ¶ˆè®¢å•åé’±æ€ä¹ˆè¿”è¿˜ï¼Ÿ",
    "answer": "è®¢å•å–æ¶ˆåï¼Œæ¬¾é¡¹ä¼šåœ¨ä¸€ä¸ªå·¥ä½œæ—¥å†…ï¼Œç›´æ¥è¿”è¿˜åˆ°æ‚¨çš„ç¾å›¢è´¦æˆ·ä½™é¢ã€‚",
    "metadata": {
      "source": "https://waimai.meituan.com/help/faq",
      "category": "æ”¯ä»˜é—®é¢˜",
      "crawl_time": "2025-09-04T02:38:28.261319+00:00"
    }
  },
  {
```

## æ–‡æ¡£æ•°æ®å‘é‡åŒ–
æˆ‘ä»¬å°† FAQ æ•°æ®æ ¼å¼åŒ–æˆ json æ•°æ®åï¼Œæ¥ä¸‹æ¥å°±è¦è½¬æˆå‘é‡æ•°æ®å¹¶å­˜å‚¨åˆ°å‘é‡æ•°æ®åº“ä¸­ï¼Œæ­¤å¤„ä»¥ redis ä¸ºä¾‹ï¼Œæ“ä½œå†…å®¹åŒ…æ‹¬ï¼š

+ ä½¿ç”¨ **å‘é‡åŒ–æ¨¡å‹ï¼ˆEmbedding Modelï¼Œå¦‚ BGEã€OpenAI Embeddingï¼‰** å°†æ–‡æ¡£ç‰‡æ®µè½¬æ¢ä¸ºå‘é‡è¡¨ç¤ºã€‚
+ å­˜å‚¨è‡³å‘é‡æ•°æ®åº“ï¼ˆå¦‚ Milvusã€Weaviateã€Redis Vectorã€Faissï¼‰ï¼Œæ”¯æŒé«˜æ•ˆçš„ç›¸ä¼¼åº¦æœç´¢ã€‚

ä»£ç å¦‚ä¸‹

```python
import os
import json
import dotenv
import dashscope
import redis
import numpy as np
from http import HTTPStatus
from redis.commands.search.field import TextField, VectorField
from redis.commands.search.index_definition import IndexDefinition

# ========== é…ç½® ==========
# åŠ è½½ç¯å¢ƒå˜é‡
dotenv.load_dotenv()
# è®¾ç½® DashScope API Key
dashscope.api_key = os.getenv("DASHSCOPE_API_KEY")

# å®šä¹‰ç´¢å¼•åç§°ã€å‘é‡ç»´åº¦å’Œè·ç¦»åº¦é‡æ–¹å¼
INDEX_NAME = "faq_index"
VECTOR_DIM = 1024
DISTANCE_METRIC = "COSINE"

# åˆå§‹åŒ– Redis å®¢æˆ·ç«¯è¿æ¥
redis_client = redis.Redis(
    host="localhost",
    port=6379,
    password=None,
    decode_responses=False
)

# ========== åˆ›å»ºç´¢å¼•ï¼ˆåªæ‰§è¡Œä¸€æ¬¡ï¼‰ ==========
def create_index():
    """
    åˆ›å»º Redis å‘é‡æœç´¢ç´¢å¼•ã€‚
    
    å¦‚æœç´¢å¼•å·²å­˜åœ¨ï¼Œåˆ™è·³è¿‡åˆ›å»ºå¹¶æç¤ºä¿¡æ¯ï¼›
    å¦åˆ™æ ¹æ®é¢„å®šä¹‰çš„å­—æ®µç»“æ„åˆ›å»ºä¸€ä¸ªæ–°çš„ç´¢å¼•ï¼Œç”¨äºæ”¯æŒ FAQ çš„æ–‡æœ¬ä¸å‘é‡æ··åˆæ£€ç´¢ã€‚
    """
    try:
        redis_client.ft(INDEX_NAME).info()
        print("âœ… ç´¢å¼•å·²å­˜åœ¨")
    except Exception:
        redis_client.ft(INDEX_NAME).create_index(
            [
                TextField("question"),
                TextField("answer"),
                TextField("source"),
                TextField("category"),
                TextField("crawl_time"),
                VectorField(
                    "embedding",
                    "HNSW",
                    {"TYPE": "FLOAT32", "DIM": VECTOR_DIM, "DISTANCE_METRIC": DISTANCE_METRIC}
                )
            ],
            definition=IndexDefinition(prefix=["faq:"])
        )
        print("âœ… å·²åˆ›å»ºå‘é‡ç´¢å¼•")

# ========== æ’å…¥ä¸€æ¡ FAQ ==========
def insert_faq(doc: dict):
    """
    å°†å•æ¡ FAQ æ•°æ®æ’å…¥ Redisï¼Œå¹¶ç”Ÿæˆå¯¹åº”çš„æ–‡æœ¬åµŒå…¥å‘é‡ã€‚

    å‚æ•°:
        doc (dict): åŒ…å«é—®é¢˜ã€ç­”æ¡ˆåŠå…ƒæ•°æ®çš„å­—å…¸ã€‚
            - question (str): é—®é¢˜å†…å®¹
            - answer (str): å›ç­”å†…å®¹
            - metadata (dict): å…ƒæ•°æ®ï¼ŒåŒ…æ‹¬ source, category, crawl_time ç­‰å­—æ®µ

    è¿”å›å€¼:
        æ— è¿”å›å€¼ã€‚ç»“æœé€šè¿‡æ‰“å°è¾“å‡ºè¡¨ç¤ºæ“ä½œæ˜¯å¦æˆåŠŸã€‚
    """
    # æ‹¼æ¥é—®é¢˜å’Œç­”æ¡ˆä½œä¸ºåµŒå…¥æ¨¡å‹çš„è¾“å…¥æ–‡æœ¬
    text_for_embedding = doc["question"] + " " + doc["answer"]

    # è°ƒç”¨ DashScope å¤šæ¨¡æ€åµŒå…¥æ¨¡å‹è·å–å‘é‡è¡¨ç¤º
    resp = dashscope.MultiModalEmbedding.call(
        model="multimodal-embedding-v1",
        input=[{"text": text_for_embedding}]
    )

    if resp.status_code == HTTPStatus.OK:
        # æå–åµŒå…¥å‘é‡å¹¶è½¬æ¢ä¸ºå­—èŠ‚æ ¼å¼ä»¥ä¾¿å­˜å‚¨åˆ° Redis ä¸­
        embedding = resp.output["embeddings"][0]["embedding"]
        vector = np.array(embedding, dtype=np.float32).tobytes()

        # æ„é€  Redis é”®å
        key = f"faq:{resp.request_id}"
        # å­˜å‚¨ FAQ æ•°æ®åŠå…¶å‘é‡è¡¨ç¤ºåˆ° Redis Hash ç»“æ„ä¸­
        redis_client.hset(key, mapping={
            "question": doc["question"],
            "answer": doc["answer"],
            "source": doc["metadata"]["source"],
            "category": doc["metadata"]["category"],
            "crawl_time": doc["metadata"]["crawl_time"],
            "embedding": vector
        })
        print(f"âœ… å·²å†™å…¥ Redis, key={key}")
    else:
        print(f"âŒ Embedding è°ƒç”¨å¤±è´¥: {resp.code}, {resp.message}")

# ========== æ‰¹é‡å¤„ç† ==========
def insert_from_file(file_path="faq_processed.json"):
    """
    ä»æŒ‡å®š JSON æ–‡ä»¶ä¸­è¯»å– FAQ æ•°æ®å¹¶é€æ¡æ’å…¥ Redisã€‚

    å‚æ•°:
        file_path (str): JSON æ ¼å¼çš„ FAQ æ•°æ®æ–‡ä»¶è·¯å¾„ï¼Œé»˜è®¤ä¸º "faq_processed.json"

    è¿”å›å€¼:
        æ— è¿”å›å€¼ã€‚æ¯æ¡æ•°æ®æ’å…¥åä¼šæ‰“å°çŠ¶æ€ä¿¡æ¯ã€‚
    """
    with open(file_path, "r", encoding="utf-8") as f:
        docs = json.load(f)

    for doc in docs:
        insert_faq(doc)

if __name__ == "__main__":
    # ç¨‹åºå…¥å£ï¼šå…ˆåˆ›å»ºç´¢å¼•å†æ‰¹é‡æ’å…¥æ•°æ®
    create_index()
    insert_from_file("faq_processed.json")

```

æŸ¥çœ‹ redis æ•°æ®å†…å®¹

![](https://via.placeholder.com/800x600?text=Image+835430cb07c55508)

## æ–‡æ¡£æ•°æ®ç›¸ä¼¼æ€§æ£€ç´¢
æ–‡æ¡£å‘é‡æ•°æ®å†™å…¥æ•°æ®åº“åï¼Œæ¥ä¸‹æ¥å°±æ˜¯æµ‹è¯•éªŒè¯å¬å›æ•°æ®å‡†ç¡®æ€§ï¼Œä¸»è¦å†…å®¹åŒ…æ‹¬ï¼š

+ ç”¨æˆ·æé—®åï¼Œå°†é—®é¢˜è½¬æ¢ä¸ºå‘é‡ï¼Œä¸å‘é‡æ•°æ®åº“ä¸­çš„æ–‡æ¡£è¿›è¡Œç›¸ä¼¼æ€§åŒ¹é…ã€‚
+ å¬å›ä¸é—®é¢˜æœ€ç›¸å…³çš„æ–‡æ¡£ç‰‡æ®µï¼ˆå¦‚é€€æ¬¾æµç¨‹ã€é…é€å»¶è¯¯è§„åˆ™ï¼‰ï¼Œå¹¶è¿”å›ç»™ä¸Šå±‚ç³»ç»Ÿã€‚

ä»£ç å¦‚ä¸‹ï¼š

```python
import os
import dotenv
import dashscope
import redis
import numpy as np
from http import HTTPStatus
from redis.commands.search.query import Query

# ========== é…ç½® ==========
# åŠ è½½ç¯å¢ƒå˜é‡
dotenv.load_dotenv()
# è®¾ç½® DashScope API å¯†é’¥
dashscope.api_key = os.getenv("DASHSCOPE_API_KEY")

# Redis å‘é‡ç´¢å¼•åç§°
INDEX_NAME = "faq_index"
# å‘é‡ç»´åº¦ï¼Œç”¨äºæ¨¡å‹ "multimodal-embedding-v1"
VECTOR_DIM = 1024
# é»˜è®¤è¿”å›æœ€ç›¸ä¼¼çš„å‰ K æ¡ç»“æœ
TOP_K = 3

# åˆå§‹åŒ– Redis å®¢æˆ·ç«¯è¿æ¥
redis_client = redis.Redis(
    host="localhost",
    port=6379,
    password=None,
    decode_responses=False
)

# ========== å°†é—®é¢˜è½¬ä¸ºå‘é‡ ==========
def embed_question(question: str):
    """
    ä½¿ç”¨ DashScope çš„å¤šæ¨¡æ€åµŒå…¥æ¨¡å‹å°†æ–‡æœ¬é—®é¢˜è½¬æ¢ä¸ºå‘é‡è¡¨ç¤ºã€‚

    å‚æ•°:
        question (str): éœ€è¦è½¬æ¢ä¸ºå‘é‡çš„æ–‡æœ¬é—®é¢˜ã€‚

    è¿”å›:
        bytes: é—®é¢˜å¯¹åº”çš„å‘é‡è¡¨ç¤ºï¼ˆä»¥å­—èŠ‚å½¢å¼è¿”å›ï¼‰ã€‚

    å¼‚å¸¸:
        RuntimeError: å¦‚æœè°ƒç”¨åµŒå…¥æœåŠ¡å¤±è´¥ï¼Œåˆ™æŠ›å‡ºè¿è¡Œæ—¶é”™è¯¯ã€‚
    """
    resp = dashscope.MultiModalEmbedding.call(
        model="multimodal-embedding-v1",
        input=[{"text": question}]
    )
    if resp.status_code == HTTPStatus.OK:
        embedding = resp.output["embeddings"][0]["embedding"]
        return np.array(embedding, dtype=np.float32).tobytes()
    else:
        raise RuntimeError(f"âŒ Embedding è°ƒç”¨å¤±è´¥: {resp.code}, {resp.message}")

# ========== ç›¸ä¼¼åº¦æœç´¢ ==========
def search_faq(question: str, top_k=TOP_K):
    """
    æ ¹æ®ç”¨æˆ·è¾“å…¥çš„é—®é¢˜ï¼Œåœ¨ Redis ä¸­è¿›è¡Œå‘é‡ç›¸ä¼¼åº¦æœç´¢ï¼Œè¿”å›æœ€ç›¸å…³çš„ FAQ æ¡ç›®ã€‚

    å‚æ•°:
        question (str): ç”¨æˆ·æå‡ºçš„é—®é¢˜ã€‚
        top_k (int): è¿”å›æœ€ç›¸ä¼¼çš„å‰ K æ¡ç»“æœï¼Œé»˜è®¤å€¼ä¸º TOP_Kã€‚
    """
    # å°†é—®é¢˜è½¬æ¢ä¸ºå‘é‡è¡¨ç¤º
    q_vector = embed_question(question)

    # æ„é€  RediSearch çš„ KNN æŸ¥è¯¢è¯­å¥
    query = (
        Query(f"*=>[KNN {top_k} @embedding $vec AS score]")
        .sort_by("score")
        .return_fields("question", "answer", "source", "category", "crawl_time", "score")
        .dialect(2)
    )

    # æ‰§è¡ŒæŸ¥è¯¢å¹¶è·å–ç»“æœ
    results = redis_client.ft(INDEX_NAME).search(query, query_params={"vec": q_vector})

    print(f"\nğŸ” ç”¨æˆ·é—®é¢˜: {question}")
    print(f"ğŸ“Š å¬å› {len(results.docs)} æ¡ç»“æœ\n")

    # æ‰“å°æ¯æ¡åŒ¹é…ç»“æœçš„è¯¦ç»†ä¿¡æ¯
    for i, doc in enumerate(results.docs, start=1):
        print(f"--- Top {i} ---")
        print(f"ç›¸ä¼¼åº¦åˆ†æ•°: {doc.score}")
        print(f"Q: {doc.question}")
        print(f"A: {doc.answer}")
        print(f"æ¥æº: {doc.source}")
        print(f"ç±»åˆ«: {doc.category}")
        print(f"æ—¶é—´: {doc.crawl_time}")
        print()

# ========== ä¸»å‡½æ•° ==========
if __name__ == "__main__":
    # æµ‹è¯•ç”¨ä¾‹ï¼šæ¨¡æ‹Ÿç”¨æˆ·æé—®
    test_question = "ä¸ºä»€ä¹ˆä¼šå‡ºç°æ— æ³•ä¸‹å•çš„æƒ…å†µï¼Ÿ"
    search_faq(test_question, top_k=3)

```

æ‰§è¡Œç»“æœå¦‚ä¸‹

```bash
ğŸ” ç”¨æˆ·é—®é¢˜: ä¸ºä»€ä¹ˆä¼šå‡ºç°æ— æ³•ä¸‹å•çš„æƒ…å†µï¼Ÿ
ğŸ“Š å¬å› 3 æ¡ç»“æœ

--- Top 1 ---
ç›¸ä¼¼åº¦åˆ†æ•°: 0.114289164543
Q: ä¸ºä»€ä¹ˆä¼šå‡ºç°æ— æ³•ä¸‹å•çš„æƒ…å†µï¼Ÿ
A: æ— æ³•ä¸‹å•æœ‰å¾ˆå¤šæƒ…å†µï¼Œå¯èƒ½æ˜¯èœå“å”®å®Œã€é¤å…ä¸åœ¨è¥ä¸šæ—¶é—´ç­‰ï¼Œè¯·æŸ¥çœ‹æ— æ³•ä¸‹å•æ—¶ç»™çš„æç¤ºã€‚
æ¥æº: https://waimai.meituan.com/help/faq
ç±»åˆ«: æ”¯ä»˜é—®é¢˜
æ—¶é—´: 2025-09-04T02:38:28.261319+00:00

--- Top 2 ---
ç›¸ä¼¼åº¦åˆ†æ•°: 0.13062286377
Q: åˆšä¸‹å•å‘ç°ä¿¡æ¯å¡«é”™äº†æ€ä¹ˆåŠï¼Ÿ
A: å¦‚æœå•†å®¶å°šæœªæ¥å•ï¼Œæ‚¨å¯ä»¥è‡ªä¸»å–æ¶ˆè®¢å•ï¼›å¦‚æœå•†å®¶å·²ç»æ¥å•ï¼Œæ‚¨å¯ä»¥ç”µè¯è”ç³»å•†å®¶åç”±å¯¹æ–¹å–æ¶ˆè®¢å•ã€‚ç„¶åé‡æ–°ä¸‹ä¸€å•ã€‚
æ¥æº: https://waimai.meituan.com/help/faq
ç±»åˆ«: æ”¯ä»˜é—®é¢˜
æ—¶é—´: 2025-09-04T02:38:28.261319+00:00

--- Top 3 ---
ç›¸ä¼¼åº¦åˆ†æ•°: 0.138350009918
Q: ä¸ºä»€ä¹ˆæç¤ºä¸‹å•æ¬¡æ•°è¿‡å¤šï¼Œå·²æ— æ³•ä¸‹å•ï¼Ÿ
A: åŒä¸€æ‰‹æœºå·åœ¨åŒä¸€è®¾å¤‡ä¸Šä¸€å¤©æœ€å¤šå¯ä»¥æˆåŠŸæäº¤7æ¬¡è®¢å•ï¼ˆåœ¨çº¿æ”¯ä»˜ä»¥å®Œæˆæ”¯ä»˜ä¸ºå‡†ï¼Œè´§åˆ°ä»˜æ¬¾ä»¥æäº¤è®¢å•ä¸ºå‡†ï¼‰ã€‚
å…¶ä»–é—®é¢˜
æ¥æº: https://waimai.meituan.com/help/faq
ç±»åˆ«: æ”¯ä»˜é—®é¢˜
æ—¶é—´: 2025-09-04T02:38:28.261319+00:00
```

## æ„å»ºæç¤ºè¯
+  æŠŠ **ç”¨æˆ·é—®é¢˜** + **æ£€ç´¢å¬å›çš„ä¸Šä¸‹æ–‡** æ‹¼æ¥æˆä¸€ä¸ªé«˜è´¨é‡çš„ Prompt é€ç»™å¤§æ¨¡å‹ã€‚  
+ æç¤ºè¯ç¤ºä¾‹ï¼š

```bash
ä½ æ˜¯ä¸€ä¸ªæ™ºèƒ½é—®ç­”åŠ©æ‰‹ï¼Œè¯·ä»…æ ¹æ®æä¾›çš„æ–‡æ¡£ç‰‡æ®µå›ç­”ç”¨æˆ·é—®é¢˜ã€‚
å¦‚æœæ–‡æ¡£ç‰‡æ®µä¸­æ²¡æœ‰ç›¸å…³å†…å®¹ï¼Œè¯·å›ç­”â€œæœªæ‰¾åˆ°ç›¸å…³ä¿¡æ¯â€ã€‚

ç”¨æˆ·é—®é¢˜ï¼š
å–æ¶ˆè®¢å•åå¤šä¹…èƒ½æ”¶åˆ°é€€æ¬¾ï¼Ÿ

å¯ç”¨æ–‡æ¡£ç‰‡æ®µï¼š
ã€æ–‡æ¡£ç‰‡æ®µ1ã€‘
Q: åœ¨çº¿æ”¯ä»˜å–æ¶ˆè®¢å•åé’±æ€ä¹ˆè¿”è¿˜ï¼Ÿ
A: è®¢å•å–æ¶ˆåï¼Œæ¬¾é¡¹ä¼šåœ¨ä¸€ä¸ªå·¥ä½œæ—¥å†…ï¼Œç›´æ¥è¿”è¿˜åˆ°æ‚¨çš„ç¾å›¢è´¦æˆ·ä½™é¢ã€‚

ã€æ–‡æ¡£ç‰‡æ®µ2ã€‘
Q: æ€ä¹ˆæŸ¥çœ‹é€€æ¬¾æ˜¯å¦æˆåŠŸï¼Ÿ
A: é€€æ¬¾ä¼šåœ¨ä¸€ä¸ªå·¥ä½œæ—¥ä¹‹å†…åˆ°ç¾å›¢è´¦æˆ·ä½™é¢ï¼Œå¯åœ¨â€œè´¦å·ç®¡ç†â€”â€”æˆ‘çš„è´¦å·â€ä¸­æŸ¥çœ‹æ˜¯å¦åˆ°è´¦ã€‚

è¯·åŸºäºä»¥ä¸Šä¿¡æ¯ï¼Œç”Ÿæˆç®€æ´æ˜äº†çš„å›ç­”ï¼š
```

æç¤ºè¯ä»£ç å¦‚ä¸‹ï¼š

```bash
import os
import dotenv
import dashscope
import redis
import numpy as np
from http import HTTPStatus
from redis.commands.search.query import Query

# ========== é…ç½® ==========
# åŠ è½½ç¯å¢ƒå˜é‡
dotenv.load_dotenv()
# è®¾ç½® DashScope API Key
dashscope.api_key = os.getenv("DASHSCOPE_API_KEY")

# Redis å‘é‡ç´¢å¼•åç§°
INDEX_NAME = "faq_index"
# å‘é‡ç»´åº¦
VECTOR_DIM = 1024
# ç›¸ä¼¼åº¦æœç´¢è¿”å›çš„æœ€ç›¸ä¼¼ç»“æœæ•°é‡
TOP_K = 3

# åˆå§‹åŒ– Redis å®¢æˆ·ç«¯è¿æ¥
redis_client = redis.Redis(
    host="localhost",
    port=6379,
    password=None,
    decode_responses=False
)

# ========== å°†é—®é¢˜è½¬ä¸ºå‘é‡ ==========
def embed_question(question: str):
    """
    ä½¿ç”¨ DashScope çš„å¤šæ¨¡æ€åµŒå…¥æ¨¡å‹å°†æ–‡æœ¬é—®é¢˜è½¬æ¢ä¸ºå‘é‡è¡¨ç¤ºã€‚

    å‚æ•°:
        question (str): ç”¨æˆ·è¾“å…¥çš„é—®é¢˜æ–‡æœ¬ã€‚

    è¿”å›:
        bytes: é—®é¢˜å¯¹åº”çš„å‘é‡è¡¨ç¤ºï¼ˆä»¥å­—èŠ‚å½¢å¼å­˜å‚¨ï¼‰ã€‚

    å¼‚å¸¸:
        RuntimeError: å½“è°ƒç”¨åµŒå…¥æœåŠ¡å¤±è´¥æ—¶æŠ›å‡ºå¼‚å¸¸ã€‚
    """
    resp = dashscope.MultiModalEmbedding.call(
        model="multimodal-embedding-v1",
        input=[{"text": question}]
    )
    if resp.status_code == HTTPStatus.OK:
        embedding = resp.output["embeddings"][0]["embedding"]
        return np.array(embedding, dtype=np.float32).tobytes()
    else:
        raise RuntimeError(f"âŒ Embedding è°ƒç”¨å¤±è´¥: {resp.code}, {resp.message}")

# ========== ç›¸ä¼¼åº¦æœç´¢ ==========
def search_faq(question: str, top_k=TOP_K):
    """
    åœ¨ Redis ä¸­åŸºäºå‘é‡ç›¸ä¼¼åº¦æœç´¢ä¸ç”¨æˆ·é—®é¢˜æœ€ç›¸å…³çš„ FAQ æ–‡æ¡£ã€‚

    å‚æ•°:
        question (str): ç”¨æˆ·æå‡ºçš„é—®é¢˜ã€‚
        top_k (int): è¿”å›æœ€ç›¸ä¼¼çš„å‰ K ä¸ªæ–‡æ¡£ï¼Œé»˜è®¤ä½¿ç”¨ TOP_K å¸¸é‡ã€‚

    è¿”å›:
        list: åŒ…å«åŒ¹é…æ–‡æ¡£å¯¹è±¡çš„åˆ—è¡¨ï¼Œæ¯ä¸ªå¯¹è±¡åŒ…å«å­—æ®µå¦‚ questionã€answerã€source ç­‰ã€‚
    """
    q_vector = embed_question(question)

    # æ„é€  Redis å‘é‡æœç´¢æŸ¥è¯¢è¯­å¥
    query = (
        Query(f"*=>[KNN {top_k} @embedding $vec AS score]")
        .sort_by("score")
        .return_fields("question", "answer", "source", "category", "crawl_time", "score")
        .dialect(2)
    )

    # æ‰§è¡Œæœç´¢å¹¶è¿”å›ç»“æœ
    results = redis_client.ft(INDEX_NAME).search(query, query_params={"vec": q_vector})
    return results.docs

# ========== æ„å»º Prompt ==========
def build_prompt(user_question: str, retrieved_docs, top_k=TOP_K) -> str:
    """
    æ ¹æ®ç”¨æˆ·é—®é¢˜å’Œæ£€ç´¢åˆ°çš„ç›¸å…³æ–‡æ¡£æ„å»ºç”¨äºå¤§æ¨¡å‹æ¨ç†çš„ Promptã€‚

    å‚æ•°:
        user_question (str): ç”¨æˆ·æå‡ºçš„é—®é¢˜ã€‚
        retrieved_docs (list): æ£€ç´¢åˆ°çš„ç›¸å…³æ–‡æ¡£åˆ—è¡¨ã€‚
        top_k (int): ä½¿ç”¨çš„æ–‡æ¡£æ•°é‡ä¸Šé™ï¼Œé»˜è®¤ä¸º TOP_Kã€‚

    è¿”å›:
        str: æ„å»ºå®Œæˆçš„ Prompt å­—ç¬¦ä¸²ã€‚
    """
    context_parts = []
    for i, doc in enumerate(retrieved_docs[:top_k], start=1):
        context_parts.append(
            f"ã€æ–‡æ¡£ç‰‡æ®µ{i}ã€‘\nQ: {doc.question}\nA: {doc.answer}"
        )
    context_text = "\n\n".join(context_parts)

    prompt = f"""
ä½ æ˜¯ä¸€ä¸ªæ™ºèƒ½é—®ç­”åŠ©æ‰‹ï¼Œè¯·ä»…æ ¹æ®æä¾›çš„æ–‡æ¡£ç‰‡æ®µå›ç­”ç”¨æˆ·é—®é¢˜ã€‚
å¦‚æœæ–‡æ¡£ç‰‡æ®µä¸­æ²¡æœ‰ç›¸å…³å†…å®¹ï¼Œè¯·å›ç­”â€œæœªæ‰¾åˆ°ç›¸å…³ä¿¡æ¯â€ã€‚

ç”¨æˆ·é—®é¢˜ï¼š
{user_question}

å¯ç”¨æ–‡æ¡£ç‰‡æ®µï¼š
{context_text}

è¯·åŸºäºä»¥ä¸Šä¿¡æ¯ï¼Œç”Ÿæˆç®€æ´æ˜äº†çš„å›ç­”ï¼š
"""
    return prompt.strip()

# ========== ä¸»å‡½æ•° ==========
if __name__ == "__main__":
    # å¾ªç¯æ¥æ”¶ç”¨æˆ·è¾“å…¥å¹¶è¿›è¡Œé—®ç­”å¤„ç†
    while True:
        user_question = input("\nè¯·è¾“å…¥é—®é¢˜ï¼ˆè¾“å…¥ exit é€€å‡ºï¼‰ï¼š")
        if user_question.lower() in ["exit", "quit"]:
            break

        docs = search_faq(user_question, top_k=TOP_K)
        if not docs:
            print("âš ï¸ æœªæ£€ç´¢åˆ°ç›¸å…³æ–‡æ¡£")
            continue

        prompt = build_prompt(user_question, docs)
        print("\n===== æ„å»ºçš„ Prompt =====\n")
        print(prompt)
        print("\n=========================\n")


```

æ‰§è¡Œç»“æœå¦‚ä¸‹

```bash
è¯·è¾“å…¥é—®é¢˜ï¼ˆè¾“å…¥ exit é€€å‡ºï¼‰ï¼šä¸ºä»€ä¹ˆä¼šå‡ºç°æ— æ³•ä¸‹å•çš„æƒ…å†µ

===== æ„å»ºçš„ Prompt =====

ä½ æ˜¯ä¸€ä¸ªæ™ºèƒ½é—®ç­”åŠ©æ‰‹ï¼Œè¯·ä»…æ ¹æ®æä¾›çš„æ–‡æ¡£ç‰‡æ®µå›ç­”ç”¨æˆ·é—®é¢˜ã€‚
å¦‚æœæ–‡æ¡£ç‰‡æ®µä¸­æ²¡æœ‰ç›¸å…³å†…å®¹ï¼Œè¯·å›ç­”â€œæœªæ‰¾åˆ°ç›¸å…³ä¿¡æ¯â€ã€‚

ç”¨æˆ·é—®é¢˜ï¼š
ä¸ºä»€ä¹ˆä¼šå‡ºç°æ— æ³•ä¸‹å•çš„æƒ…å†µ

å¯ç”¨æ–‡æ¡£ç‰‡æ®µï¼š
ã€æ–‡æ¡£ç‰‡æ®µ1ã€‘
Q: ä¸ºä»€ä¹ˆä¼šå‡ºç°æ— æ³•ä¸‹å•çš„æƒ…å†µï¼Ÿ
A: æ— æ³•ä¸‹å•æœ‰å¾ˆå¤šæƒ…å†µï¼Œå¯èƒ½æ˜¯èœå“å”®å®Œã€é¤å…ä¸åœ¨è¥ä¸šæ—¶é—´ç­‰ï¼Œè¯·æŸ¥çœ‹æ— æ³•ä¸‹å•æ—¶ç»™çš„æç¤ºã€‚

ã€æ–‡æ¡£ç‰‡æ®µ2ã€‘
Q: åˆšä¸‹å•å‘ç°ä¿¡æ¯å¡«é”™äº†æ€ä¹ˆåŠï¼Ÿ
A: å¦‚æœå•†å®¶å°šæœªæ¥å•ï¼Œæ‚¨å¯ä»¥è‡ªä¸»å–æ¶ˆè®¢å•ï¼›å¦‚æœå•†å®¶å·²ç»æ¥å•ï¼Œæ‚¨å¯ä»¥ç”µè¯è”ç³»å•†å®¶åç”±å¯¹æ–¹å–æ¶ˆè®¢å•ã€‚ç„¶åé‡æ–°ä¸‹ä¸€å•ã€‚

ã€æ–‡æ¡£ç‰‡æ®µ3ã€‘
Q: ä¸ºä»€ä¹ˆæç¤ºä¸‹å•æ¬¡æ•°è¿‡å¤šï¼Œå·²æ— æ³•ä¸‹å•ï¼Ÿ
A: åŒä¸€æ‰‹æœºå·åœ¨åŒä¸€è®¾å¤‡ä¸Šä¸€å¤©æœ€å¤šå¯ä»¥æˆåŠŸæäº¤7æ¬¡è®¢å•ï¼ˆåœ¨çº¿æ”¯ä»˜ä»¥å®Œæˆæ”¯ä»˜ä¸ºå‡†ï¼Œè´§åˆ°ä»˜æ¬¾ä»¥æäº¤è®¢å•ä¸ºå‡†ï¼‰ã€‚
å…¶ä»–é—®é¢˜

è¯·åŸºäºä»¥ä¸Šä¿¡æ¯ï¼Œç”Ÿæˆç®€æ´æ˜äº†çš„å›ç­”ï¼š

=========================


è¯·è¾“å…¥é—®é¢˜ï¼ˆè¾“å…¥ exit é€€å‡ºï¼‰ï¼šexit
```

## å¤§è¯­è¨€æ¨¡å‹ç”Ÿæˆç»“æœ
æç¤ºè¯æ„å»ºå®ŒæˆéªŒè¯æ— è¯¯åï¼Œæ¥ä¸‹æ¥è°ƒç”¨å¤§æ¨¡å‹å¯¹ç»“æœè¿›è¡Œå›ç­”æ—¢å¯

+ è°ƒç”¨å¤§è¯­è¨€æ¨¡å‹ï¼ˆå¦‚ DeepSeekã€ChatGPTã€é€šä¹‰åƒé—®ç­‰ï¼‰ç”Ÿæˆè‡ªç„¶è¯­è¨€å›ç­”ã€‚

ä»£ç å¦‚ä¸‹ï¼š

```python
import os
import dotenv
import dashscope
import redis
import numpy as np
from http import HTTPStatus
from redis.commands.search.query import Query
from openai import OpenAI

# ========== é…ç½® ==========
dotenv.load_dotenv()
dashscope.api_key = os.getenv("DASHSCOPE_API_KEY")

INDEX_NAME = "faq_index"
VECTOR_DIM = 1024
TOP_K = 3

redis_client = redis.Redis(
    host="localhost",
    port=6379,
    password=None,
    decode_responses=False
)

# åˆå§‹åŒ– OpenAI å®¢æˆ·ç«¯ï¼ˆå…¼å®¹ DashScopeï¼‰
client = OpenAI(
    api_key=os.getenv("BAILIAN_API_KEY"),
    base_url=os.getenv("BAILIAN_BASE_URL")
)

# ========== å°†é—®é¢˜è½¬ä¸ºå‘é‡ ==========
def embed_question(question: str):
    resp = dashscope.MultiModalEmbedding.call(
        model="multimodal-embedding-v1",
        input=[{"text": question}]
    )
    if resp.status_code == HTTPStatus.OK:
        embedding = resp.output["embeddings"][0]["embedding"]
        return np.array(embedding, dtype=np.float32).tobytes()
    else:
        raise RuntimeError(f"âŒ Embedding è°ƒç”¨å¤±è´¥: {resp.code}, {resp.message}")

# ========== ç›¸ä¼¼åº¦æœç´¢ ==========
def search_faq(question: str, top_k=TOP_K):
    q_vector = embed_question(question)

    query = (
        Query(f"*=>[KNN {top_k} @embedding $vec AS score]")
        .sort_by("score")
        .return_fields("question", "answer", "source", "category", "crawl_time", "score")
        .dialect(2)
    )

    results = redis_client.ft(INDEX_NAME).search(query, query_params={"vec": q_vector})
    return results.docs

# ========== æ„å»º Prompt ==========
def build_prompt(user_question: str, retrieved_docs, top_k=TOP_K) -> str:
    context_parts = []
    for i, doc in enumerate(retrieved_docs[:top_k], start=1):
        context_parts.append(
            f"ã€æ–‡æ¡£ç‰‡æ®µ{i}ã€‘\nQ: {doc.question}\nA: {doc.answer}"
        )
    context_text = "\n\n".join(context_parts)

    prompt = f"""
    ä½ æ˜¯ä¸€ä¸ªæ™ºèƒ½é—®ç­”åŠ©æ‰‹ï¼Œè¯·ä»…æ ¹æ®æä¾›çš„æ–‡æ¡£ç‰‡æ®µå›ç­”ç”¨æˆ·é—®é¢˜ã€‚
    å¦‚æœæ–‡æ¡£ç‰‡æ®µä¸­æ²¡æœ‰ç›¸å…³å†…å®¹ï¼Œè¯·å›ç­”â€œæœªæ‰¾åˆ°ç›¸å…³ä¿¡æ¯â€ã€‚
    
    ç”¨æˆ·é—®é¢˜ï¼š
    {user_question}
    
    å¯ç”¨æ–‡æ¡£ç‰‡æ®µï¼š
    {context_text}
    
    è¯·åŸºäºä»¥ä¸Šä¿¡æ¯ï¼Œç”Ÿæˆç®€æ´æ˜äº†çš„å›ç­”ï¼š
    """
    return prompt.strip()

# ========== è°ƒç”¨å¤§æ¨¡å‹ ==========
def ask_llm(prompt: str) -> str:
    completion = client.chat.completions.create(
        model="deepseek-r1-distill-llama-70b",  # ä¹Ÿå¯ä»¥æ¢æˆ qwen-turbo / qwen-plus ç­‰
        messages=[{"role": "user", "content": prompt}]
    )

    # è¾“å‡ºæœ€ç»ˆç­”æ¡ˆ
    return completion.choices[0].message.content

# ========== ä¸»ç¨‹åº ==========
if __name__ == "__main__":
    while True:
        user_question = input("\nè¯·è¾“å…¥é—®é¢˜ï¼ˆè¾“å…¥ exit é€€å‡ºï¼‰ï¼š")
        if user_question.lower() in ["exit", "quit"]:
            break

        docs = search_faq(user_question, top_k=TOP_K)
        if not docs:
            print("âš ï¸ æœªæ£€ç´¢åˆ°ç›¸å…³æ–‡æ¡£")
            continue

        prompt = build_prompt(user_question, docs)
        # print("\n===== æ„å»ºçš„ Prompt =====\n")
        # print(prompt)
        # print("\n=========================\n")

        answer = ask_llm(prompt)
        print("ğŸ’¡ å¤§æ¨¡å‹å›ç­”ï¼š")
        print(answer)

```

æ‰§è¡Œç»“æœå¦‚ä¸‹

```bash
è¯·è¾“å…¥é—®é¢˜ï¼ˆè¾“å…¥ exit é€€å‡ºï¼‰ï¼šä¸ºä»€ä¹ˆä¼šå‡ºç°æ— æ³•ä¸‹å•çš„æƒ…å†µ
ğŸ’¡ å¤§æ¨¡å‹å›ç­”ï¼š
æ— æ³•ä¸‹å•çš„æƒ…å†µå¯èƒ½æ˜¯ç”±äºèœå“å”®å®Œã€é¤å…ä¸åœ¨è¥ä¸šæ—¶é—´ç­‰åŸå› ã€‚è¯·æŸ¥çœ‹ä¸‹å•æ—¶çš„æç¤ºä¿¡æ¯ä»¥è·å–å…·ä½“åŸå› ã€‚
```


