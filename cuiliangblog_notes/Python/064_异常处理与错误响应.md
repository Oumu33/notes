# 异常处理与错误响应
> 在 Web 开发中，异常处理是不可或缺的一环。FastAPI 提供了灵活且优雅的异常处理机制，既可以使用内置的 HTTPException 抛出错误，也可以自定义异常类和全局异常处理器来构建统一的错误响应结构。掌握这些特性，可以让你的 API 更加健壮、易于调试，同时也便于前端统一处理错误提示。
>

# 使用 HTTPException 抛出错误
最常见的做法是使用 FastAPI 提供的 `HTTPException`，它允许你直接抛出一个带有状态码、错误信息的响应：

```python
from fastapi import FastAPI, HTTPException

app = FastAPI()


@app.get("/items/{item_id}")
def read_item(item_id: int):
    """
    根据物品ID获取物品信息
    
    参数:
        item_id (int): 物品的唯一标识符
        
    返回值:
        dict: 包含物品ID的字典对象
        
    异常:
        HTTPException: 当物品ID不等于42时抛出404异常
    """
    # 只有当物品ID等于42时才认为物品存在，否则抛出404异常
    if item_id != 42:
        raise HTTPException(status_code=404, detail="Item not found", headers={"X-Error": "AccessDenied"})
    return {"item_id": item_id}

```

# 处理请求验证错误
FastAPI 使用 Pydantic 来自动校验请求参数和请求体。如果校验失败，会自动返回 `422 Unprocessable Entity` 错误。

例如：

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    price: float


@app.post("/items/")
def create_item(item: Item):
    return item
```

请求体中如果 `price` 为字符串，FastAPI 会自动返回校验错误信息。

# 自定义异常类
你可以定义自己的异常类型，便于分类处理：

```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
app = FastAPI()

class MyCustomError(Exception):
    """
    自定义异常类，用于处理特定的业务错误
    
    Args:
        name (str): 错误名称
        message (str): 错误详细信息
    """
    def __init__(self, name: str, message: str):
        self.name = name
        self.message = message

@app.exception_handler(MyCustomError)
async def my_custom_exception_handler(request: Request, exc: MyCustomError):
    """
    自定义异常处理器，用于处理MyCustomError异常并返回统一格式的JSON响应
    
    Args:
        request (Request): HTTP请求对象
        exc (MyCustomError): 捕获到的自定义异常实例
        
    Returns:
        JSONResponse: 包含错误信息的JSON响应对象
    """
    return JSONResponse(
        status_code=400,
        content={
            "error": exc.name,
            "message": exc.message,
            "path": request.url.path,
        },
    )

@app.get("/trigger-error")
async def trigger_error():
    """
    触发自定义错误的测试接口
    
    Raises:
        MyCustomError: 总是抛出一个预定义的自定义异常
    """
    raise MyCustomError(name="InvalidRequest", message="你发送了一个无效请求！")

```

# 统一错误响应结构
在生产环境中，建议你返回统一结构的错误响应，方便前端处理。例如：

```json
{
  "code": 1001,
  "message": "资源未找到",
  "data": null
}
```

你可以定义一个公共异常响应函数：

```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
app = FastAPI()

class AppException(Exception):
    """
    应用程序自定义异常类
    
    Args:
        code (int): 错误码
        message (str): 错误信息
    """
    def __init__(self, code: int, message: str):
        self.code = code
        self.message = message


# 注册应用程序异常处理器，用于统一处理AppException异常
@app.exception_handler(AppException)
async def app_exception_handler(request: Request, exc: AppException):
    """
    处理AppException异常，返回统一格式的JSON响应
    
    Args:
        request (Request): HTTP请求对象
        exc (AppException): 捕获到的应用程序异常对象
    
    Returns:
        JSONResponse: 包含错误码、错误信息和数据的JSON响应
    """
    return JSONResponse({
        "code": exc.code,
        "message": exc.message,
        "data": None
    })


@app.get("/error")
def raise_error():
    """
    测试接口，用于触发并抛出AppException异常
    
    Raises:
        AppException: 抛出资源未找到的异常，错误码为1001
    """
    raise AppException(code=1001, message="资源未找到")

```

# 处理请求验证错误格式
FastAPI 默认返回的校验错误结构较复杂，但你可以自定义格式：

```python
from fastapi import FastAPI, Request
from fastapi.exceptions import RequestValidationError
from fastapi.responses import JSONResponse


app = FastAPI()


@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    """
    处理请求验证异常的全局异常处理器
    
    当FastAPI在请求参数验证过程中发现错误时，会调用此处理器返回统一格式的错误响应
    
    参数:
        request (Request): HTTP请求对象
        exc (RequestValidationError): 请求验证异常对象
    
    返回:
        JSONResponse: 包含错误信息的JSON响应对象
    """
    return JSONResponse({
        "code": 1004,
        "message": "请求参数错误",
        "data": None
    })


@app.get("/hello")
def hello(name: str):
    """
    处理GET请求的/hello端点，返回问候语
    
    参数:
        name (str): 用户名称参数
    
    返回:
        dict: 包含问候语信息的字典对象
    """
    return {"code": 0, "message": "成功", "data": f"Hello {name}"}

```


