# 中间件

> 分类: Python > FastAPI
> 更新时间: 2026-01-10T23:34:33.586038+08:00

---

> 在 FastAPI 中，中间件（Middleware）是一种非常实用的机制，它允许你在请求进入和响应返回之间插入自定义逻辑。通过中间件，你可以统一处理日志、性能监控、身份验证、错误捕获、响应头设置等跨请求功能。
>

# 中间件介绍
## 什么是中间件
中间件（Middleware）是介于请求进入应用与响应返回客户端之间的一段可插入逻辑。你可以把它想象成一个“过滤器”或“拦截器”，在每一次请求或响应时都能自动运行。

中间件的典型应用场景包括：

+ 请求日志记录
+ 性能分析（记录耗时）
+ 全局错误处理
+ 添加/修改响应头
+ 统一身份认证与权限校验
+ 实现自定义跨域处理等

FastAPI 支持两种中间件写法：

+ 函数式中间件（使用 `@app.middleware("http")` 装饰器）
+ 类式中间件（使用 `app.add_middleware()` 注册 Starlette 中间件类）

# 定义中间件
## 函数式中间件
对于自定义的中间件，FastAPI 支持使用装饰器方式注册。例如，下面示例使用 `@app.middleware("http")` 装饰器注册中间件函数。

```python
from fastapi import FastAPI, Request
import time

app = FastAPI()

@app.middleware("http")
async def log_request_time(request: Request, call_next):
    """
    记录HTTP请求处理时间的中间件函数
    
    该函数会测量每个HTTP请求的处理时间，并将耗时信息添加到响应头中，
    同时在控制台输出请求方法、路径和处理时间。
    
    参数:
        request (Request): FastAPI的请求对象，包含HTTP请求信息
        call_next: 下一个中间件或路由处理函数的调用对象
    
    返回:
        Response: 处理后的HTTP响应对象，包含添加的处理时间头部信息
    """
    start_time = time.time()
    response = await call_next(request)  # 将请求传递给下一个处理器
    duration = time.time() - start_time
    # 将处理时间添加到响应头中
    response.headers["X-Process-Time"] = str(duration)
    # 在控制台打印请求信息和处理时间
    print(f"{request.method} {request.url.path} - 耗时 {duration:.4f} 秒")
    return response
```

函数式中间件结构说明：

+ `request`：表示当前请求对象，可以从中读取请求方法、路径、头信息等；
+ `call_next(request)`：表示将请求传递给下一个处理器（通常是对应的路由函数）；
+ `response`：得到的响应对象，可以在返回前修改内容或响应头。

参数说明：

+ `@app.middleware("http")` 中的 `"http"` 是中间件类型的标识，目前 FastAPI 只支持 `"http"` 类型的中间件。它的意思是：这个中间件将 应用于所有的 HTTP 请求，包括 GET、POST、PUT、DELETE 等方法的请求。也就是说，只要有 HTTP 请求进入你的应用，这个中间件就会被触发。

> 提示：FastAPI 基于 Starlette 构建，而 `"http"` 类型中间件是 Starlette 定义的一种标准，用于处理 HTTP 请求/响应流程。
>

## 类式中间件
对于标准化或封装好的中间件（如 CORS、GZip 等），FastAPI 支持使用 `add_middleware` 注册类的方式注册中间件。

例如，如果你的前后端分离应用遇到跨域问题，可以添加官方提供的 `CORSMiddleware`。

```plain
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

这种方式的底层实现是 Starlette 的中间件类，与函数式中间件功能类似，但写法更适合标准中间件组件。

# 中间件使用
## 日志记录
```python
@app.middleware("http")
async def log_requests(request: Request, call_next):
    print(f"请求路径：{request.url.path}")
    response = await call_next(request)
    return response
```

## 请求耗时统计
```python
@app.middleware("http")
async def timer(request: Request, call_next):
    start = time.time()
    response = await call_next(request)
    response.headers["X-Time"] = f"{time.time() - start:.2f}s"
    return response
```

## 全局异常捕获（高级用法）
虽然 FastAPI 提供了异常处理机制，但你也可以用中间件统一捕获错误日志：

```python
@app.middleware("http")
async def catch_errors(request: Request, call_next):
    try:
        return await call_next(request)
    except Exception as e:
        print(f"捕获异常：{e}")
        return JSONResponse(status_code=500, content={"detail": "服务器错误"})
```

## 自定义类中间件
你也可以自己封装类中间件（继承 `BaseHTTPMiddleware`）：

```python
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.requests import Request
from starlette.responses import Response

class AddHeaderMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        response = await call_next(request)
        response.headers["X-Custom-Header"] = "Hello"
        return response

app.add_middleware(AddHeaderMiddleware)
```

>  提示：相对于函数式中间件，类式中间件支持更多高级特性，比如构造函数中传入参数等。
>

# 总结
## 中间件执行顺序说明
中间件的执行顺序遵循“洋葱模型”：

1. 注册顺序决定嵌套层级；
2. 请求从外向里传递，响应从里向外传递。

举例：

```python
from fastapi import FastAPI

app = FastAPI()

@app.middleware("http")
async def outer(request, call_next):
    """
    HTTP中间件函数，在请求处理前后执行额外逻辑
    
    Args:
        request: HTTP请求对象，包含客户端发送的请求信息
        call_next: 异步可调用对象，用于继续执行下一个中间件或路由处理函数
    
    Returns:
        Response: HTTP响应对象，返回给客户端的响应结果
    """
    # 在请求处理前打印日志
    print("outer: before")
    # 调用下一个中间件或路由处理函数
    response = await call_next(request)
    # 在请求处理后打印日志
    print("outer: after")
    return response

@app.middleware("http")
async def inner(request, call_next):
    """
    HTTP中间件函数，在请求处理前后执行额外逻辑
    
    Args:
        request: HTTP请求对象，包含客户端发送的请求信息
        call_next: 异步可调用对象，用于继续执行下一个中间件或路由处理函数
    
    Returns:
        Response: HTTP响应对象，返回给客户端的响应结果
    """
    # 在请求处理前打印日志
    print("inner: before")
    # 调用下一个中间件或路由处理函数
    response = await call_next(request)
    # 在请求处理后打印日志
    print("inner: after")
    return response
```

请求顺序为 `outer before` → `inner before` → … → `inner after` → `outer after`。

## 类式中间件 vs 函数式中间件
| 特性 | 函数式中间件 | 类式中间件 |
| --- | --- | --- |
| 写法 | 使用装饰器 | 使用 `add_middleware()` |
| 适合场景 | 自定义逻辑简单处理 | 引入已有组件（如 CORS、GZip） |
| 性能 | 非常高效 | 稍有额外开销 |
| 灵活性 | 高 | 更标准化、可配置 |


