# 安全上下文

> 分类: Kubernetes > 安全
> 更新时间: 2026-01-10T23:33:24.844805+08:00

---

# 简介
在我们使用某些镜像挂载持久化存储后，经常遇到提示无权限写入的问题，这就是因为持久化存储目录用户和用户组为root，而容器运行用户非root导致，此时就需要使用安全上下文解决这个问题。

安全上下文定义 Pod 或 Container 的特权与访问控制设置。 安全上下文包括但不限于：

+ 自主访问控制（Discretionary Access Control）： 基于用户 ID（UID）和组 ID（GID） 来判定对对象（例如文件）的访问权限。
+ 安全性增强的 Linux（SELinux）： 为对象赋予安全性标签。
+ 以特权模式或者非特权模式运行。
+ Linux 权能: 为进程赋予 root 用户的部分特权而非全部特权。
+ AppArmor：使用程序配置来限制个别程序的权能。
+ Seccomp：过滤进程的系统调用。
+ allowPrivilegeEscalation：控制进程是否可以获得超出其父进程的特权。 此布尔值直接控制是否为容器进程设置 no_new_privs标志。 当容器满足一下条件之一时，allowPrivilegeEscalation 总是为 true：
    - 以特权模式运行，或者
    - 具有 CAP_SYS_ADMIN 权能
+ readOnlyRootFilesystem：以只读方式加载容器的根文件系统。

# 设置pod<font style="color:rgb(34, 34, 34);">安全性上下文</font>
## 配置字段
runAsUser字段：指定Pod中的所有容器内的进程都使用指定用户ID来运行。

runAsGroup 字段：指定所有容器中的进程都以主组 ID来运行。 如果忽略此字段，则容器的主组 ID 将是 root（0）。

fsGroup字段：容器中挂载卷及在该卷中创建的任何文件的属主都会是指定组ID。

## 示例文件
```yaml
[root@k8s-master ~]# cat pod.yaml 
apiVersion: v1
kind: Pod
metadata:
  name: mypod
  labels:
    name: mypod
spec:
  containers:
  - name: mypod
    image: busybox
    command: [ "sh", "-c", "sleep 1h" ]
    volumeMounts:
    - name: data
      mountPath: /data/demo
  securityContext:
    runAsUser: 1000   # pod进程用户id
    runAsGroup: 3000  # pod进程用户组id
    fsGroup: 2000     # 挂载卷文件组id
  volumes:
  - name: data
    emptyDir: {}
[root@k8s-master ~]# kubectl apply -f pod.yaml 
pod/mypod created
[root@k8s-master ~]# kubectl get pod 
NAME                      READY   STATUS    RESTARTS      AGE
mypod                     1/1     Running   0             26s
```

## 验证
```bash
# 进入容器
[root@k8s-master ~]# kubectl exec -it mypod -- sh
# 查看进程信息，用户id为1000
/ $ ps
PID   USER     TIME  COMMAND
    1 1000      0:00 sleep 1h
    7 1000      0:00 sh
   13 1000      0:00 ps

# 容器内创建文件，查看文件权限，用户组id为3000
/ $ echo hello > /tmp/tmpfile
/ $ ls -l /tmp/tmpfile 
-rw-r--r--    1 1000     3000             6 Jun  2 07:43 /tmp/tmpfile

# 挂载卷内创建文件，查看文件权限，用户id为1000，用户组id为2000
/ $ ls -l /data/demo/
total 4
-rw-r--r--    1 1000     2000             6 Jun  2 07:38 testfile
/ $ ls -l /data/demo/testfile 
-rw-r--r--    1 1000     2000             6 Jun  2 07:38 /data/demo/testfile
```

# 为container设置安全性上下文
除了可以对pod设置安全性上下文外，若一个pod中存在多个container，可以为每个containe单独设置安全性上下文，container的优先级高于pod。

## 示例文件
```yaml
[root@k8s-master ~]# cat pod.yaml 
apiVersion: v1
kind: Pod
metadata:
  name: mypod
  labels:
    name: mypod
spec:
  containers:
  - name: polic1
    image: busybox
    command: [ "sh", "-c", "sleep 1h" ]
    securityContext:
      runAsUser: 1100
  - name: polic2
    image: busybox
    command: [ "sh", "-c", "sleep 1h" ]
    securityContext:
      runAsGroup: 1200
  securityContext:
    runAsUser: 1000
    runAsGroup: 3000
[root@k8s-master ~]# kubectl apply -f pod.yaml 
pod/mypod created
```

## 验证
查看polic1的安全信息

```bash
[root@k8s-master ~]# kubectl exec -it mypod -c polic1 -- sh
# 查看用户ID信息，虽然pod指定用户id为1000，但是container指定用户id为1100，因此显示1100
/ $ ps	
PID   USER     TIME  COMMAND
    1 1100      0:00 sleep 1h
   19 1100      0:00 sh
   25 1100      0:00 ps
/ $ echo hello > /tmp/file
# 查看用户组ID信息，container未设置，使用pod设置的用户组id
/ $ ls -l /tmp/file
-rw-r--r--    1 1100     3000             6 Jun  2 08:01 /tmp/file
```

查看polic2的信息，与container1同理

```bash
[root@k8s-master ~]# kubectl exec -it mypod -c polic2 -- sh
/ $ ps
PID   USER     TIME  COMMAND
    1 1000      0:00 sleep 1h
    7 1000      0:00 sh
   13 1000      0:00 ps
/ $ echo hello > /tmp/file
/ $ ls -l /tmp/file
-rw-r--r--    1 1000     1200             6 Jun  2 08:01 /tmp/file
```

# <font style="color:rgb(34, 34, 34);">pod访问目录权限不足问题</font>
## 目录指定权限问题
例如在部署pgsql过程中，要求数据目录必须为700，此时就需要在init过程中修改数据目录权限，yaml文件如下：

```yaml
initContainers:
  - name: fix-permissions
    image: busybox:1.28.4-glibc
    command: ["sh", "-c", "chmod -R 700 /var/lib/postgresql; chown 999:999 /var/lib/postgresql"]
    securityContext:
      privileged: true # 特权模式执行
    volumeMounts:
      - name: data
        mountPath: /var/lib/postgresql
containers:
  - name: postgresql
    image: postgresql
    imagePullPolicy: IfNotPresent
    ports:
      - name: postgres
        containerPort: 5432
    volumeMounts:
      - mountPath: /var/lib/postgresql
        name: data
volumes:
  - name: data
    persistentVolumeClaim:
      claimName: postgresql-pvc
```

# 挂载hostPath无法创建文件问题
例如使用hostPath方式挂载宿主机目录，创建文件时会有以下报错。

```bash
httpd@hostpath-volume:/test-volume$ touch  123
touch: cannot touch '123': Permission denied
```

**问题的根源**

<font style="color:rgb(89, 97, 114);">容器挂载hostPath写入时报错Permission denied时基本都是容器运行用户不是root的情况下，这就说明，启动容器的用户没有权限在宿主机中属主属组为root的目录或者文件中写入。</font>

## <font style="color:rgb(89, 97, 114);">方案1：赋予运行容器的用户写权限</font>
<font style="color:rgb(89, 97, 114);">只要赋予运行容器的用户写权限，这个问题就解决了。</font>

**<font style="color:rgb(89, 97, 114);">查看容器uid</font>**

```bash
## 容器内
httpd@hostpath-volume:/test-volume$ id
uid=1000(httpd) gid=1000(httpd) groups=1000(httpd)
```

**<font style="color:rgb(89, 97, 114);">赋予宿主机对应uid用户权限</font>**

<font style="color:rgb(89, 97, 114);background-color:rgb(248, 248, 248);">如果没有相同uid的用户，则创建一个对应用户即可：useradd -u 1000 httpd</font>

```bash
## 宿主机
chown httpd:httpd test/

## 容器内
httpd@hostpath-volume:/test-volume$ touch 11 22 33
httpd@hostpath-volume:/test-volume$ ls
11  22	33
```

## 方案2：让pod以root用户运行
```bash

apiVersion: v1
kind: Pod
metadata:
  name: security-context-demo
spec:
  securityContext:
    runAsUser: 0
    runAsGroup: 0
    fsGroup: 0
```

