# ES写入原理

> 分类: ELK Stack > ES基础与部署
> 更新时间: 2026-01-10T23:33:32.058670+08:00

---

# 倒排索引与分词
## 正排索引
正排索引就是最普通的索引排序方式。正排索引也是采取key-value pair的方式对数据进行保存，key是doc-id，value则可以存储多种内容，如doc的分词词表、doc所在网页的属性信息等。由此可见，正排索引可以随意添加数据，但如果你要查询某个单词在哪些文档中出现，那么你就不得不将全部文档都遍历一遍，效率极低。

| 文档ID | 文档内容 |
| --- | --- |
| 1 | elasticsearch是最流行的搜索引擎 |
| 2 | php是世界上最好的语言 |
| 3 | 搜索引擎是如何诞生的 |


## <font style="color:black;">倒排索引</font>
倒排索引类似将正排索引反过来，以全部文档中出现的所有words建立一个词典（term dictionary ），然后对于term dictionary 中的每个词，它后面都会跟随一个链表，该链表就是倒排表 ，倒排表内存储着如下信息：

该词出现的doc-id

该词在某doc中的出现次数和出现位置

如此一来，倒排索引就可以在用户输入查询query时，将query分词成一个个token，然后将一个个token带到term dictionary 去“查字典”，然后获得出现该词的doc-id集合，最终在这若干个token对应的若干doc-id集合上做交集，得到最符合用户query查询的结果。

由此可见，倒排索引大大加快了查询速度，然而一旦有新的文档加入文档库，你就要重新做一次"入库操作"，即建立倒排索引的操作。因为此时各个token在不同文档中的出现次数、以及每个token对应的 倒排表 都可能发生变化。

| 单词 | 文档ID |
| --- | --- |
| elasticsearch | 1 |
| 流行 | 1 |
| 搜索引擎 | 1，3 |
| php | 2 |
| 世界 | 2 |
| 最好 | 2 |
| 语言 | 2 |
| 如何 | 3 |
| 诞生 | 3 |


# 写索引原理
## 数据复制模型
  
Elasticsearch 中的每个索引都被划分为shard，每个shard 可以有多个副本，这些副本称为副本组，在添加或删除文档时必须保持同步。

## 路由（routing）
1. 在ELasticsearch中，会采用计算的方式来确定存储到哪个节点，计算公式如下：

`shard = hash(routing) % number_1 of_primary_shards`

+ routing值是一个任意字符串，它默认是_id但也可以自定义。
+ 这个routing字符串通过哈希函数生成一个数字，然后除以主切片的数量得到一个余数(remainder)，余数的范围永远是0到number_of_primary_shards      - 1，这个数字就是特定文档所在的分片。
2. 这就是为什么创建了主分片后，不能修改的原因。因为如果数量变化了，那么所有之前路由的值都会无效，文档也再也找不到了。

## 写入过程
1. 新建、索引和删除请求都是写(write)操作，它们必须在主分片上成功完成才能复制到相关的复制分片上。

![](../../images/img_1757.png)

2. 下面我们罗列在主分片和复制分片上成功新建、索引或删除一个文档必要的顺序步骤：
+ 客户端给Node 1 发送新建、索引或删除请求。
+ 节点使用文档的_id 确定文档属于分片0 。它转发请求到Node      3 ，分片0 位于这个节点上。
+ Node 3      在主分片上执行请求，如果成功，它转发请求到相应的位于Node 1 和Node 2 的复制节点上。当所有的复制节点报告成功， Node 3      报告成功到请求的节点，请求的节点再报告给客户端。
+ 客户端接收到成功响应的时候，文档的修改已经被应用于主分片和所有的复制分片。你的修改生效了。

# 存储原理
## 分段存储（<font style="color:black;">segment</font>）
索引文档以段的形式存储在磁盘上，何为段？索引文件被拆分为多个子文件，则每个子文件叫作段，每一个段本身都是一个倒排索引，并且段具有不变性，一旦索引的数据被写入硬盘，就不可再修改。

在底层采用了分段的存储模式，使它在读写时几乎完全避免了锁的出现，大大提升了读写性能。

段被写入到磁盘后会生成一个提交点，提交点是一个用来记录所有提交后段信息的文件。

一个段一旦拥有了提交点，就说明这个段只有读的权限，失去了写的权限。相反，当段在内存中时，就只有写的权限，而不具备读数据的权限，意味着不能被检索。

段的概念提出主要是因为：在早期全文检索中为整个文档集合建立了一个很大的倒排索引，并将其写入磁盘中。

如果索引有更新，就需要重新全量创建一个索引来替换原来的索引。这种方式在数据量很大时效率很低，并且由于创建一次索引的成本很高，所以对数据的更新不能过于频繁，也就不能保证时效性。

索引文件分段存储并且不可修改，那么新增、更新和删除如何处理呢？

+ 新增，新增很好处理，由于数据是新的，所以只需要对当前文档新增一个段就可以了。
+ 删除，由于不可修改，所以对于删除操作，不会把文档从旧的段中移除而是通过新增一个 .del 文件，文件中会列出这些被删除文档的段信息。这个被标记删除的文档仍然可以被查询匹配到， 但它会在最终结果被返回前从结果集中移除。
+ 更新，不能修改旧的段来进行反映文档的更新，其实更新相当于是删除和新增这两个动作组成。会将旧的文档在 .del 文件中标记删除，然后文档的新版本被索引到一个新的段中。可能两个版本的文档都会被一个查询匹配到，但被删除的那个旧版本文档在结果集返回前就会被移除。

段被设定为不可修改具有一定的优势也有一定的缺点，优势主要表现在：

+ 不需要锁。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题。
+ 一旦索引被读入内核的文件系统缓存，便会留在哪里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升。
+ 其它缓存(像 Filter 缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。
+ 写入单个大的倒排索引允许数据被压缩，减少磁盘 I/O 和需要被缓存到内存的索引的使用量。

段的不变性的缺点如下：

+ 当对旧数据进行删除时，旧数据不会马上被删除，而是在 .del 文件中被标记为删除。而旧数据只能等到段更新时才能被移除，这样会造成大量的空间浪费。
+ 若有一条数据频繁的更新，每次更新都是新增新的标记旧的，则会有大量的空间浪费。
+ 每次新增数据时都需要新增一个段来存储数据。当段的数量太多时，对服务器的资源例如文件句柄的消耗会非常大。
+ 在查询的结果中包含所有的结果集，需要排除被标记删除的旧数据，这增加了查询的负担。

## <font style="color:black;">延迟写入（</font><font style="color:black;">refresh</font><font style="color:black;">）</font>
![](../../images/img_1758.png)

如果是数据直接写入到磁盘上，磁盘的 I/O 消耗上会严重影响性能。

那么当写数据量大的时候会造成 ES 停顿卡死，查询也无法做到快速响应。如果真是这样 ES 也就不会称之为近实时全文搜索引擎了。

为了提升写的性能，ES 并没有每新增一条数据就增加一个段到磁盘上，而是采用延迟写的策略。

每当有新增的数据时，就将其先写入到内存中，在内存和磁盘之间是文件系统缓存。

当达到默认的时间（1 秒钟）或者内存的数据达到一定量时，会触发一次刷新（Refresh），将内存中的数据生成到一个新的段上并缓存到文件缓存系统 上，稍后再被刷新到磁盘中并生成提交点。

这里的内存使用的是 ES 的 JVM 内存，而文件缓存系统使用的是操作系统的内存。

新的数据会继续的被写入内存，但内存中的数据并不是以段的形式存储的，因此不能提供检索功能。

由内存刷新到文件缓存系统的时候会生成新的段，并将段打开以供搜索使用，而不需要等到被刷新到磁盘。

在 Elasticsearch 中，写入和打开一个新段的轻量的过程叫做 Refresh （即内存刷新到文件缓存系统）。

默认情况下每个分片会每秒自动刷新一次。这就是为什么我们说 Elasticsearch 是近实时搜索，因为文档的变化并不是立即对搜索可见，但会在一秒之内变为可见。

我们也可以手动触发 Refresh，POST /_refresh 刷新所有索引，POST /nba/_refresh 刷新指定的索引。

Tips：尽管刷新是比提交轻量很多的操作，它还是会有性能开销。当写测试的时候， 手动刷新很有用，但是不要在生产>环境下每次索引一个文档都去手动刷新。而且并不是所有的情况都需要每秒刷新。

可能你正在使用 Elasticsearch 索引大量的日志文件， 你可能想优化索引速度而不是>近实时搜索。

这时可以在创建索引时在 Settings 中通过调大 refresh_interval = "30s" 的值 ， 降低每个索引的刷新频率，设值时需要注意后面带上时间单位，否则默认是毫秒。当 refresh_interval=-1 时表示关闭索引的自动刷新。

## 事务日志（<font style="color:rgb(74, 74, 74);">Translog</font>）
<font style="color:rgb(74, 74, 74);">虽然通过延时写的策略可以减少数据往磁盘上写的次数提升了整体的写入能力，但是我们知道文件缓存系统也是内存空间，属于操作系统的内存，只要是内存都存在断电或异常情况下丢失数据的危险。</font>

<font style="color:rgb(74, 74, 74);">为了避免丢失数据，Elasticsearch 添加了事务日志（Translog），事务日志记录了所有还没有持久化到磁盘的数据。</font>

<font style="color:rgb(74, 74, 74);">添加了事务日志后整个写索引的流程如上图所示：</font>

+ <font style="color:rgb(74, 74, 74);">一个新文档被索引之后，先被写入到内存中，但是为了防止数据的丢失，会追加一份数据到事务日志中。</font><font style="color:rgb(74, 74, 74);">不断有新的文档被写入到内存，同时也都会记录到事务日志中。这时新数据还不能被检索和查询。</font>
+ <font style="color:rgb(74, 74, 74);">当达到默认的刷新时间或内存中的数据达到一定量后，会触发一次  Refresh，将内存中的数据以一个新段形式刷新到文件缓存系统中并清空内存。这时虽然新段未被提交到磁盘，但是可以提供文档的检索功能且不能被修改。</font>
+ <font style="color:rgb(74, 74, 74);">随着新文档索引不断被写入，当日志数据大小超过 512M 或者时间超过 30 分钟时，会触发一次 Flush。</font><font style="color:rgb(74, 74, 74);">内存中的数据被写入到一个新段同时被写入到文件缓存系统，文件系统缓存中数据通过 Fsync 刷新到磁盘中，生成提交点，日志文件被删除，创建一个空的新日志。</font>

<font style="color:rgb(74, 74, 74);">通过这种方式当断电或需要重启时，ES 不仅要根据提交点去加载已经持久化过的段，还需要工具 Translog 里的记录，把未持久化的数据重新持久化到磁盘上，避免了数据丢失的可能。</font>

## <font style="color:rgb(74, 74, 74);">段合并（</font><font style="color:black;">flush</font><font style="color:rgb(74, 74, 74);">）</font>
![](../../images/img_1759.png)

<font style="color:rgb(74, 74, 74);">由于自动刷新流程每秒会创建一个新的段 ，这样会导致短时间内的段数量暴增。而段数目太多会带来较大的麻烦。</font>

<font style="color:rgb(74, 74, 74);">每一个段都会消耗文件句柄、内存和 CPU 运行周期。更重要的是，每个搜索请求都必须轮流检查每个段然后合并查询结果，所以段越多，搜索也就越慢。</font>

<font style="color:rgb(74, 74, 74);">Elasticsearch 通过在后台定期进行段合并来解决这个问题。小的段被合并到大的段，然后这些大的段再被合并到更大的段。</font>

<font style="color:rgb(74, 74, 74);">段合并的时候会将那些旧的已删除文档从文件系统中清除。被删除的文档不会被拷贝到新的大段中。合并的过程中不会中断索引和搜索。</font>

<font style="color:rgb(74, 74, 74);">段合并在进行索引和搜索时会自动进行，合并进程选择一小部分大小相似的段，并且在后台将它们合并到更大的段中，这些段既可以是未提交的也可以是已提交的。</font>

<font style="color:rgb(74, 74, 74);">合并结束后老的段会被删除，新的段被 Flush 到磁盘，同时写入一个包含新段且排除旧的和较小的段的新提交点，新的段被打开可以用来搜索。</font>

<font style="color:rgb(74, 74, 74);">段合并的计算量庞大， 而且还要吃掉大量磁盘 I/O，段合并会拖累写入速率，如果任其发展会影响搜索性能。</font>

<font style="color:rgb(74, 74, 74);">Elasticsearch 在默认情况下会对合并流程进行资源限制，所以搜索仍然有足够的资源很好地执行。</font>

