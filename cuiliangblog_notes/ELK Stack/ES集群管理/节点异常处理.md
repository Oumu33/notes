# 节点异常处理
# 节点cpu过高
<font style="color:rgb(62, 62, 62);">如果出现节点占用CPU很高，我们需要知道CPU在运行什么任务，一般通过线程堆栈来查看。</font>

<font style="color:rgb(62, 62, 62);">这里有两种方式可以查看哪些线程CPU占用率比较高：</font>

1. <font style="color:rgb(62, 62, 62);">使用</font><font style="color:rgb(62, 62, 62);">ElasticSearch</font><font style="color:rgb(62, 62, 62);">提供的hot_threads api查看；</font>
2. <font style="color:rgb(62, 62, 62);">使用jstack和top命令查看，针对java应用cpu过高问题的这个是通用做法。</font>

<font style="color:rgb(62, 62, 62);">这里推荐使用hot_threads api</font>

<font style="color:rgb(51, 51, 51);">GET /_nodes/hot_threadsGET /_nodes/<node_id>/hot_threads</font><font style="color:rgb(51, 51, 51);"></font>

<font style="color:rgb(62, 62, 62);">通过返回的结果可以看到什么线程占用更高，正在做什么操作。</font>

<font style="color:rgb(62, 62, 62);">更详细的内容可以参考官网：</font>

<font style="color:rgb(62, 62, 62);">https://www.elastic.co/guide/en/elasticsearch/reference/7.17/cluster-nodes-hot-threads.html</font>

# 内存使用率过高
## 缓存类型**<font style="color:rgb(62, 62, 62);"></font>**
<font style="color:rgb(62, 62, 62);">首先我们需要了解ES中的缓存类型，缓存主要分成如图所示三大类，如下图所示，一个es节点的内存结构：</font>

![](../../images/img_1845.png)<font style="color:rgb(62, 62, 62);">  
</font>

<font style="color:rgb(62, 62, 62);">Node Query Cache（Filter Context）</font>

+ <font style="color:rgb(62, 62, 62);">每一个节点有一个Node Query缓存</font>
+ <font style="color:rgb(62, 62, 62);">由该节点的所有Shard共享，只缓存Filter Context 相关内容</font>
+ <font style="color:rgb(62, 62, 62);">Cache采用LRU算法，不会被jvm gc</font>
+ <font style="color:rgb(62, 62, 62);">Segment级缓存命中的结果。Segment被合并后，缓存会失效</font>
+ <font style="color:rgb(62, 62, 62);">缓存的配置项设置为</font>

<font style="color:rgb(51, 51, 51);">index.queries.cache.enabled: trueindices.queries.cache.size:10%</font><font style="color:rgb(51, 51, 51);">  
</font>

<font style="color:rgb(62, 62, 62);">Shard Query Cache（Cache Query的结果）</font>

+ <font style="color:rgb(62, 62, 62);">缓存每个分片上的查询结果</font><font style="color:rgb(62, 62, 62);">只会缓存设置了size=0的查询对应的结果。不会缓存hits。但是会缓存 Aggregations和Suggestions</font>
+ <font style="color:rgb(62, 62, 62);">Cache Key</font><font style="color:rgb(62, 62, 62);">LRU算法，将整个JSON查询串作为Key，与JSON对象的顺序相关，不会被jvm gc</font>
+ <font style="color:rgb(62, 62, 62);">分片Refresh时候，Shard Request Cache会失效。如果Shard对应的数据频繁发生变化，该缓存的效率会很差</font>
+ <font style="color:rgb(62, 62, 62);">配置项</font>

```plain
indices.requests.cache.size: “1%”
```

<font style="color:rgb(62, 62, 62);">Fielddata Cache</font>

+ <font style="color:rgb(62, 62, 62);">除了Text类型，默认都采用doc_values。节约了内存。</font>
+ <font style="color:rgb(62, 62, 62);">Aggregation的Global ordinals也保存在Fielddata cache 中</font>
+ <font style="color:rgb(62, 62, 62);">Text类型的字段需要打开Fileddata才能对其进行聚合和排序</font><font style="color:rgb(62, 62, 62);">Text经过分词，排序和聚合效果不佳，建议不要轻易使用。</font>
+ <font style="color:rgb(62, 62, 62);">Segment被合并后，会失效</font>
+ <font style="color:rgb(62, 62, 62);">配置项，调整该参数避免产生GC（默认无限制）：</font>

```plain
Indices.fielddata.cache.size
```

<font style="color:rgb(62, 62, 62);">Segments Cache</font>

<font style="color:rgb(62, 62, 62);">（segments FST数据的缓存），为了加速查询，FST永驻堆内内存，无法被GC回收。该部分内存无法设置大小，长期占用50%~70%的堆内存，只能通过delete index，close index以及force-merge index释放内存</font>

<font style="color:rgb(62, 62, 62);">ES底层存储采用Lucene（搜索引擎），写入时会根据原始数据的内容，分词，然后生成倒排索引。查询时，先通过查询倒排索引找到数据地址（DocID）），再读取原始数据（行存数据、列存数据）。</font>

<font style="color:rgb(62, 62, 62);">但由于Lucene会为原始数据中的每个词都生成倒排索引，数据量较大。所以倒排索引对应的倒排表被存放在磁盘上。</font>

<font style="color:rgb(62, 62, 62);">这样如果每次查询都直接读取磁盘上的倒排表，再查询目标关键词，会有很多次磁盘IO，严重影响查询性能。为了解磁盘IO问题，Lucene引入排索引的二级索引FST[Finite State Transducer]。原理上可以理解为前缀树，加速查询</font>

## 节点的内存查看
```json
GET _cat/nodes?v
GET _nodes/stats/indices?pretty
GET _cat/nodes?v&h=name,queryCacheMemory,queryCacheEvictions,requestCacheMemory,request CacheHitCount,request_cache.miss_count
GET _cat/nodes?h=name,port,segments.memory,segments.index_writer_memory,fielddata.memory_size,query_cache.memory_size,request_cache.memory_size&v
```

## 案例分析<font style="color:rgb(62, 62, 62);"></font>
<font style="color:rgb(62, 62, 62);">如果节点出现了集群整体响应缓慢，也没有特别多的数据读写。但是发现节点在持续进行Full GC。</font>

<font style="color:rgb(62, 62, 62);">常见原因：</font>

**<font style="color:rgb(62, 62, 62);">Segments个数过多，导致Full GC</font>**

<font style="color:rgb(62, 62, 62);">我们可以通过查看</font><font style="color:rgb(62, 62, 62);">ElasticSearch</font><font style="color:rgb(62, 62, 62);">的内存分析命令发现：</font>

<font style="color:rgb(62, 62, 62);">segments.memory占用很大空间。</font>

**<font style="color:rgb(62, 62, 62);">解决方案：</font>**

+ <font style="color:rgb(62, 62, 62);">通过force merge，把segments合并成一个</font>
+ <font style="color:rgb(62, 62, 62);">对于不在写入和更新的索引，可以将其设置成只读。同时，进行force merge 操作。如果问题依然存在，则需要考虑扩容。此外，对索引进行 force merge，还可以减少对global_ordinals数据结构的构建，减少对fielddata cache的开销</font>

**<font style="color:rgb(62, 62, 62);">Field data cache 过大，导致Full GC</font>**

<font style="color:rgb(62, 62, 62);">我们可以查看</font><font style="color:rgb(62, 62, 62);">ElasticSearch</font><font style="color:rgb(62, 62, 62);">的内存使用，发现fielddata.memory.size占用很大空间。同时，数据不存在写入和更新，也执行过segments merge。</font>

**<font style="color:rgb(62, 62, 62);">解决方案：</font>**

+ <font style="color:rgb(62, 62, 62);">将indices.fielddata.cache.size设小，重启节点，堆内存恢复正常</font>
+ <font style="color:rgb(62, 62, 62);">Field data cache的构建比较重，</font><font style="color:rgb(62, 62, 62);">ElasticSearch</font><font style="color:rgb(62, 62, 62);">不会主动释放，所以这个值应该设置的保守一些。如果业务上确实有所需要，可以通过增加节点，扩容解决。</font>

**<font style="color:rgb(62, 62, 62);">复杂的嵌套聚合，导致集群Full GC</font>**

<font style="color:rgb(62, 62, 62);">节点响应缓慢，持续进行Full GC。导出Dump分析。发现内存中有大量 bucket对象，查看日志，发现复杂的嵌套聚合</font>

**<font style="color:rgb(62, 62, 62);">解决方案：</font>**

+ <font style="color:rgb(62, 62, 62);">优化聚合方式</font>
+ <font style="color:rgb(62, 62, 62);">在大量数据集上进行嵌套聚合查询，需要很大的堆内存来完成。如果业务场景确实需要。则需要增加硬件进行扩展。同时，为了避免这类查询影响整个集群，需要设置Circuit Breaker和search.max_buckets的数值</font>

## 断路器
<font style="color:rgb(62, 62, 62);">es有多种断路器，我们可以合理使用，避免不合理操作引发的OOM，每个断路器可以指定内存使用的限制。</font>

<font style="color:rgb(62, 62, 62);">关于es的断路器使用可以参考官网文档：</font>

<font style="color:rgb(62, 62, 62);">https://www.elastic.co/cn/blog/improving-node-resiliency-with-the-real-memory-circuit-breaker</font>

<font style="color:rgb(51, 51, 51);">  
</font>

