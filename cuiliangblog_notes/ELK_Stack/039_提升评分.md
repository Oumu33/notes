# 提升评分
## ES查询相关性如何控制
全文搜索引擎Elasticsearch中不仅需要找到匹配的文档，还需根据它们相关度的高低进行排序。

实现相关度排序的核心概念是评分。

_score就是Elasticsearch检索返回的评分。该得分衡量每个文档与查询的匹配程度。

```plain
"hits" : [
      {
        "_index" : "kibana_sample_data_flights",
        "_type" : "_doc",
        "_id" : "FHLWlHABl_xiQyn7bHe2",
        "_score" : 3.4454226,
```

每个文档都有与之相关的评分，该得分由正浮点数表示。文档分数越高，则文档越相关。

分数与查询匹配成正比。查询中的每个子句都将有助于文档的得分。

## <font style="color:#000000;">哪些查询影响相关性</font>
布尔查询中的每个must，should和must_not元素称为查询子句。

+ 文档满足must或 should条款的标准的程度有助于文档的相关性得分。分数越高，文档就越符合您的搜索条件。
+ must_not子句中的条件被视为过滤器。它会影响文档是否包含在结果中，但不会影响文档的评分方式。在must_not里还可以显式指定任意过滤器，以基于结构化数据包括或排除文档。
+ filter：必须 匹配，但它以不评分、过滤模式来进行。filter内部语句对评分没有贡献，只是根据过滤标准来排除或包含文档。

一句话概括：filter、must_not不影响评分，其他影响评分。

## <font style="color:#000000;">如何自定义评分</font>
### Index Boost 索引层面修改相关性
+ 原理说明

允许在跨多个索引搜索时为每个索引配置不同的级别。

+ 适用场景

索引级别调整评分。

+ 实战举例：

> 一批数据里，有不同的标签，数据结构一致，不同的标签存储到不同的索引（A、B、C），最后要严格按照标签来分类展示的话，用什么查询比较好？
>
> 要求：先展示A类，然后B类，然后C类
>

```json
# 插入数据
PUT index_a/_doc/1
{
  "subject": "subject 1"
}
PUT index_b/_doc/1
{
  "subject": "subject 1"
}
PUT index_c/_doc/1
{
  "subject": "subject 1"
}
# 查询时指定index权重
GET index_*/_search
{
  "indices_boost": [
    {
      "index_a": 1.5
    },
    {
      "index_b": 1.2
    },
    {
      "index_c": 1
    }
  ],
  "query": {
    "term": {
      "subject.keyword": {
        "value": "subject 1"
      }
    }
  }
}
# 响应
{
  "took" : 12,
  "timed_out" : false,
  "_shards" : {
    "total" : 3,
    "successful" : 3,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 3,
      "relation" : "eq"
    },
    "max_score" : 0.43152314,
    "hits" : [
      {
        "_index" : "index_a",
        "_type" : "_doc",
        "_id" : "1",
        "_score" : 0.43152314,
        "_source" : {
          "subject" : "subject 1"
        }
      },
      {
        "_index" : "index_b",
        "_type" : "_doc",
        "_id" : "1",
        "_score" : 0.34521848,
        "_source" : {
          "subject" : "subject 1"
        }
      },
      {
        "_index" : "index_c",
        "_type" : "_doc",
        "_id" : "1",
        "_score" : 0.2876821,
        "_source" : {
          "subject" : "subject 1"
        }
      }
    ]
  }
}
```

### boosting 修改文档相关性
boosting分为两种类型：

+ 第一种：索引期间修改文档的相关性。

```plain
PUT my_index
{
  "mappings": {
    "properties": {
      "title": {
        "type": "text",
        "boost": 2
      }
    }
  }
}
```

索引期间修改相关性的**弊端**非常明显：**修改boost值的唯一方式是重建索引，reindex数据，成本太高了**！

+ 第二种：查询的时候修改文档的相关性。

**原理说明**

通过boosting修改文档相关性。

+ boost取值：0 - 1 之间的值，如：0.2，代表降低评分；
+ boost取值：> 1， 如：1.5，代表提升评分。

**适用场景**

自定义修改满足某个查询条件的评分。

```json
POST _search
{
  "query": {
    "bool": {
      "must": [
        {
          "multi_match": {
            "query": "pingpang best",
            "fields": [
              "title^3",
              "content"
            ]
          }
        }
      ],
      "should": [
        {
          "term": {
            "user": {
              "value": "Kimchy",
              "boost": 0.8
            }
          }
        },
        {
          "match": {
            "title": {
              "query": "quick brown fox",
              "boost": 2
            }
          }
        }
      ]
    }
  }
}
```

### negative_boost 降低相关性
**原理说明**

+ negative_boost 对 negative部分query生效，
+ 计算评分时，boosting部分评分不修改，negative部分query 乘以 negative_boost值。
+ negative_boost 取值：0-1.0，举例：0.3。

**适用场景**

对某些返回结果不满意，但又不想排除掉（must_not），可以考虑boosting query的negative_boost

```json
GET /_search
{
    "query": {
        "boosting" : {
            "positive" : {
                "term" : {
                    "text" : "apple"
                }
            },
            "negative" : {
                 "term" : {
                     "text" : "pie tart fruit crumble tree"
                }
            },
            "negative_boost" : 0.5
        }
    }
}
```

### function_score 自定义评分
**原理说明**

支持用户自定义一个或多个查询或者脚本，达到精细化控制评分的目的。

**适用场景**

支持针对复杂查询的自定义评分业务场景。

**实战一把**

实战问题1：如何同时根据 销量和浏览人数进行相关度提升？

问题来源：[https://elasticsearch.cn/question/4345](https://elasticsearch.cn/question/4345)

问题描述：针对商品，例如有

| 商品 | 销量 | 浏览人数 |
| --- | --- | --- |
| A | 10 | 10 |
| B | 20 | 20 |
| C | 30 | 30 |


想要有一个提升相关度的计算，同时针对销量和浏览人数

例如oldScore*(销量+浏览人数) field_value_factor好像只能支持单个field 求大神解答？

解答，可以借助：script_score实现。

实战如下：

```plain
PUT product_test/_bulk
{"index":{"_id":1}}
{"name":"A","sales":10,"visitors":10}
{"index":{"_id":2}}
{"name":"B","sales":20,"visitors":20}
{"index":{"_id":3}}
{"name":"C","sales":30,"visitors":30}
POST product_test/_search
{
  "query": {
    "function_score": {
      "query": {
        "match_all": {}
      },
      "script_score": {
        "script": {
          "source": "_score * (doc['sales'].value+doc['visitors'].value)"
        }
      }
    }
  }
}
```

**实战问题2：**基于文章点赞数计算评分。以下：title代表文章标题；like：代表点赞数。

期望评分标准：基于点赞数评分，且最终评分相对平滑。

**核心原理：**field_value_factor函数使用文档中的字段来影响得分。

```plain
DELETE news_index
POST news_index/_bulk
{"index":{"_id":1}}
{"title":"ElasticSearch原理- 神一样的存在"}
{"index":{"_id":2}}
{"title":"Elasticsearch 快速开始","like":5}
{"index":{"_id":3}}
{"title":"开源搜索与分析· Elasticsearch","like":10}
{"index":{"_id":4}}
{"title":"铭毅天下 死磕Elasticsearch", "like":1000}
GET news_index/_search
{
  "query": {
    "function_score": {
      "query": {
        "match": {
          "title": "Elasticsearch"
        }
      },
      "field_value_factor": {
        "field": "like",
        "modifier": "log1p",
        "factor": 0.1,
        "missing": 1
      },
      "boost_mode": "sum"
    }
  }
}
```

注意：

+ 评分计算公式解读：new_score = old_score + log(1 + 0.1 * like值)
+ missing含义：使用 field_value_factor 时要注意，有的文档可能会缺少这个字段，加上 missing 来个这些缺失字段的文档一个缺省值

### rescore_query查询后二次打分
**原理说明**

二次评分是指重新计算查询返回结果文档中指定个数文档的得分，Elasticsearch会截取查询返回的前N个，并使用预定义的二次评分方法来重新计算他们的得分。

**适用场景**

对查询语句的结果不满意，需要重新打分的场景。

但，如果对全部有序的结果集进行重新排序的话势必开销会很大，使用rescore_query只对结果集的子集进行处理。

**实战一把**

在自定义评分基础上实战

```plain
GET news_index/_search
{
  "query": {
    "exists": {
      "field": "like"
    }
  },
  "rescore": {
    "window_size": 50,
    "query": {
      "rescore_query": {
        "function_score": {
          "script_score": {
            "script": {
              "source": "doc.like.value"
            }
          }
        }
      }
    }
  }
}
```

**window_size含义**：

query rescorer仅对query和 post_filter阶段返回的前K个结果执行第二个查询。

每个分片上要检查的文档数量可由window_size参数控制，默认为10。

## 参考文档
boosting：[https://www.elastic.co/guide/en/elasticsearch/reference/7.13/query-dsl-boosting-query.html](https://www.elastic.co/guide/en/elasticsearch/reference/7.13/query-dsl-boosting-query.html)


