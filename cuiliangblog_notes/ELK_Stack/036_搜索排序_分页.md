# 搜索排序 分页

> 来源: ELK Stack
> 创建时间: 2022-05-07T10:45:59+08:00
> 更新时间: 2026-01-11T09:26:21.953398+08:00
> 阅读量: 1037 | 点赞: 0

---

## 排序
### 指定单字段排序
```bash
# 全文检索hobby为eat drink的文档，并按age字段做降序排列
GET query_test/_search
{
  "query": {
    "match": {
      "hobby": "eat drink"
    }
  },
  "sort": [
    {
      "age": {
        "order": "desc"
      }
    }
  ]
}
# 响应
{
  "took" : 4,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 3,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [
      {
        "_index" : "query_test",
        "_type" : "_doc",
        "_id" : "2",
        "_score" : null,
        "_source" : {
          "id" : "2",
          "name" : "join",
          "age" : 33,
          "email" : "test2@163.com",
          "hobby" : "study sleep eat",
          "birth" : "1989-12-12"
        },
        "sort" : [
          33
        ]
      },
      {
        "_index" : "query_test",
        "_type" : "_doc",
        "_id" : "3",
        "_score" : null,
        "_source" : {
          "id" : "3",
          "name" : "tom",
          "age" : 12,
          "email" : "query_test3@126.com",
          "hobby" : "sleep eat",
          "birth" : "2010-06-18"
        },
        "sort" : [
          12
        ]
      },
      {
        "_index" : "query_test",
        "_type" : "_doc",
        "_id" : "1",
        "_score" : null,
        "_source" : {
          "id" : "1",
          "name" : "alex1",
          "age" : 2,
          "email" : "query_test1@qq.com",
          "hobby" : "eat drink play happy",
          "birth" : "2020-01-02"
        },
        "sort" : [
          2
        ]
      }
    ]
  }
}
```

### 多字段排序
```bash
# 全文检索hobby字段值read music的文档，并按_id字段做升序排列
GET query_test/_search
{
  "query": {
    "match": {
      "hobby": "read music"
    }
  },
  "sort": [
    {
      "age": {
        "order": "desc"
      },
      "_id":{
        "order": "asc"
      }
    }
  ]
}
```

## 分页
### 基于 from、size 分页
<font style="color:rgb(33, 37, 41);">默认情况下，搜索返回前 10 个匹配结果，可以通过制定</font>from、size参数实现分页效果。

```bash
GET query_test/_search
{
  "query": {
    "match_all": {}
  },
  "from": 2,
  "size": 3
}
# 响应
{
  "took" : 2,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 6,
      "relation" : "eq"
    },
    "max_score" : 1.0,
    "hits" : [
      {
        "_index" : "query_test",
        "_type" : "_doc",
        "_id" : "3",
        "_score" : 1.0,
        "_source" : {
          "id" : "3",
          "name" : "tom",
          "age" : 12,
          "email" : "query_test3@126.com",
          "hobby" : "sleep eat",
          "birth" : "2010-06-18"
        }
      },
      {
        "_index" : "query_test",
        "_type" : "_doc",
        "_id" : "5",
        "_score" : 1.0,
        "_source" : {
          "id" : "5",
          "name" : "tory",
          "age" : 42,
          "email" : "query_test5@qq.com",
          "hobby" : "football basketball",
          "birth" : "1980-05-04"
        }
      },
      {
        "_index" : "query_test",
        "_type" : "_doc",
        "_id" : "6",
        "_score" : 1.0,
        "_source" : {
          "id" : "6",
          "name" : "alex2",
          "age" : 22,
          "email" : "query_test6@qq.com",
          "hobby" : "read music movie",
          "birth" : "2000-03-03"
        }
      }
    ]
  }
}
```

### 基于scroll深度分页
如果数据量太大，通过传统的from + size的方式并不能获取所有的数据（默认最大记录数10000），因为随着页数的增加，会消耗大量的内存，导致ES集群不稳定。

scroll api提供了一个全局深度翻页的操作， 首次请求会返回一个scroll_id，使用该scroll_id可以顺序获取下一批次的数据；scroll 请求不能用来做用户端的实时请求，只能用来做线下大量数据的翻页处理，例如数据的导出、迁移和_reindex操作。

+ 首次查询，<font style="color:rgb(64, 64, 64);">其中scroll=1m是指scroll_id保留上下文的时间</font>

```json
# 请求
GET fix-snmp-2022.12/_search?scroll=1m
{
  "query": {
    "range": {
      "timestamp": {
        "gte": "2022-12-10T17:40:00.00+08:00",
        "lt": "2022-12-10T17:59:59.00+08:00"
      }
    }
  },
  "sort": [
    {
      "timestamp": {
        "order": "asc"
      }
    }
  ],
  "size": 1000
}
# 响应
{
  "_scroll_id" : "FGluY2x1ZGVfY29udGV4dF91dWlkDXF1ZXJ5QW5kRmV0Y2gBFmgtZDNMUDdlUU9HQ1ZNOV9YNWdZaVEAAAAAABxatxZjS1NHMUdyMlJCaTFJUlFLU21tZFhB",
  "took" : 1766,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 6394,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : […………]
  }
}
```

+ 再次请求

```json
# 请求
GET _search/scroll?scroll=1m
{
  "scroll_id" : "FGluY2x1ZGVfY29udGV4dF91dWlkDXF1ZXJ5QW5kRmV0Y2gBFmgtZDNMUDdlUU9HQ1ZNOV9YNWdZaVEAAAAAABxAVhZjS1NHMUdyMlJCaTFJUlFLU21tZFhB"
}
# 响应
{
  "_scroll_id" : "FGluY2x1ZGVfY29udGV4dF91dWlkDXF1ZXJ5QW5kRmV0Y2gBFmgtZDNMUDdlUU9HQ1ZNOV9YNWdZaVEAAAAAABxatxZjS1NHMUdyMlJCaTFJUlFLU21tZFhB",
  "took" : 183,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 6394,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [……]
  }
}
```

重复请求scroll，直到hits返回值为空，翻页查询完毕。

### sliced scroll
sliced scroll api 除指定上下文保留时间外，还需要指定最大切片和当前切片，最大切片数据一般和shard数一致或者小于shard数，每个切片的scroll操作和scroll api的操作是一致的：

```json
GET /twitter/_search?scroll=1m
{
    "slice": {
        "id": 0, 
        "max": 2 
    },
    "query": {
        "match" : {
            "title" : "elasticsearch"
        }
    }
}
GET /twitter/_search?scroll=1m
{
    "slice": {
        "id": 1,
        "max": 2
    },
    "query": {
        "match" : {
            "title" : "elasticsearch"
        }
    }
}
```

因为支持并行处理，执行时间要比scroll快很多。

### search after
上面两种翻页的方式都无法支撑用户在线高并发操作，search_after提供了一种动态指针的方案，即基于上一页排序值检索下一页实现动态分页：

+ 首次查询

```json
GET twitter/_search
{
    "size": 10,
    "query": {
        "match" : {
            "title" : "elasticsearch"
        }
    },
    "sort": [
        {"date": "asc"},
        {"tie_breaker_id": "asc"}      
    ]
}
```

+ 通过上一页返回的date + tie_breaker_id最后一个值做为这一页的search_after:

```json
GET twitter/_search
{
    "size": 10,
    "query": {
        "match" : {
            "title" : "elasticsearch"
        }
    },
    "search_after": [1463538857, "654323"],
    "sort": [
        {"_score": "desc"},
        {"tie_breaker_id": "asc"}
    ]
}

```

说白了 search_after 并没有解决随机跳页查询的场景，但是可以支撑多query并发请求；search_after 操作需要指定一个支持排序且值唯一的字段用来做下一页拉取的指针，这种翻页方式也可以通过bool查询的range filter实现。

## 参考文档
es搜索结果排序：[https://www.elastic.co/guide/en/elasticsearch/reference/7.13/sort-search-results.html](https://www.elastic.co/guide/en/elasticsearch/reference/7.13/sort-search-results.html)

es搜索结果分页：[https://www.elastic.co/guide/en/elasticsearch/reference/7.13/paginate-search-results.html](https://www.elastic.co/guide/en/elasticsearch/reference/7.13/paginate-search-results.html)


