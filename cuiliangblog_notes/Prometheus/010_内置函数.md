# 内置函数
# 简介
<font style="color:rgb(48, 48, 48);">有些函数有默认参数，例如</font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">year(v=vector(time()) instant-vector)</font><font style="color:rgb(48, 48, 48);">。这意味着有一个参数 v 是一个瞬时向量，如果没有提供，它将默认为表达式</font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">vector(time())</font><font style="color:rgb(48, 48, 48);">的值。instant-vector 表示参数类型。</font>

<font style="color:rgb(48, 48, 48);">Prometheus 当前有 42 个内置函数。分别如下：</font>

```plain
abs()
absent()
absent_over_time()
ceil()
changes()
clamp()
clamp_max()
clamp_min()
day_of_month()
day_of_week()
days_in_month()
delta()
deriv()
exp()
floor()
histogram_quantile()
holt_winters()
hour()
idelta()
increase()
irate()
label_join()
label_replace()
ln()
log2()
log10()
minute()
month()
predict_linear()
rate()
resets()
round()
scalar()
sgn()
sort()
sort_desc()
sqrt()
time()
timestamp()
vector()
year()
<aggregation>_over_time()
```

# 聚合函数
<font style="color:rgb(48, 48, 48);">对指标进行求和、求平均、计数、最大值、最小值、Top 、Bottom、百分位数等数据聚合操作函数。</font>

+ <font style="color:rgb(48, 48, 48);">sum 函数</font>
+ <font style="color:rgb(48, 48, 48);">avg() 函数</font>
+ <font style="color:rgb(48, 48, 48);">count() 函数</font>
+ <font style="color:rgb(48, 48, 48);">count_values() 函数</font>
+ <font style="color:rgb(48, 48, 48);">min() 函数</font>
+ <font style="color:rgb(48, 48, 48);">max() 函数</font>
+ <font style="color:rgb(48, 48, 48);">stddev() 函数</font>
+ <font style="color:rgb(48, 48, 48);">stdvar() 函数</font>
+ <font style="color:rgb(48, 48, 48);">topk() 函数</font>
+ <font style="color:rgb(48, 48, 48);">bottomk() 函数</font>
+ <font style="color:rgb(48, 48, 48);">quantile() 函数</font>

# 类型函数
## <font style="color:rgb(53, 53, 53);">vector()</font>
<font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">vector(s scalar)</font><font style="color:rgb(48, 48, 48);"> 函数将标量 s 作为没有标签的向量返回，即返回结果为：key: value= {}, s。例如，</font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">vector(1024)</font><font style="color:rgb(48, 48, 48);"> 返回 </font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">{} 1024</font><font style="color:rgb(48, 48, 48);">例如，</font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">sum(node_not_metrics)</font><font style="color:rgb(48, 48, 48);"> 或者 </font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">vector(1024)</font><font style="color:rgb(48, 48, 48);"> 返回 </font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">{} 1024</font><font style="color:rgb(48, 48, 48);">，不存在的指标也始终返回一个样本。</font>

## <font style="color:rgb(53, 53, 53);">scalar()</font>
<font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">scalar(v instant-vector)</font><font style="color:rgb(48, 48, 48);"> 函数的参数是一个单元素的瞬时向量,它返回其唯一的时间序列的值作为一个标量。如果度量指标的样本数量大于 1 或者等于 0, 则返回 NaN。</font>

```plain
# 1.处理标量常量且仅仅适用于瞬时向量的数学函数scalar(sqrt(vector(4)))  # >> scalar  2
# 2.与时间函数连用scalar(year())  # >> scalar  2021
# 3.为你提供计算机CPU非空闲的时间比例(使用scalar会丢失所有的标签)sum(rate(node_cpu_seconds_total{mode!="idle"}[5m])) / scalar(count(node_cpu_seconds_total{mode="idle"})) # {} 0.017490234375018142
```

# <font style="color:rgb(53, 53, 53);">数学函数</font>
## <font style="color:rgb(53, 53, 53);">abs()</font>
<font style="background-color:rgb(241, 243, 245);">abs(v instant-vector)</font> 返回输入向量，所有样本值都转换为其绝对值。

这个针对单个 Metric 没什么效果，或者说这个函数应该是用在两个 Metric 做差的时候，保证结果永远是正数。

## <font style="color:rgb(53, 53, 53);">ln()</font>
<font style="background-color:rgb(241, 243, 245);">ln(v instant-vector)</font> 计算瞬时向量 v 中所有样本数据的自然对数。特殊情况：

+ ln(+Inf) = +Inf
+ ln(0) = -Inf
+ ln(x < 0) = NaN
+ ln(NaN) = NaN

## <font style="color:rgb(53, 53, 53);">log2()</font>
<font style="background-color:rgb(241, 243, 245);">log2(v instant-vector)</font> 函数计算瞬时向量 v 中所有样本数据的二进制对数。特殊情况:

+ ln(+Inf) = +Inf
+ ln(0) = -Inf
+ ln(x < 0) = NaN
+ ln(NaN) = NaN

比如：

```plain
log2(vector(2)) # {} 1
```

## <font style="color:rgb(53, 53, 53);">log10()</font>
<font style="background-color:rgb(241, 243, 245);">log10(v instant-vector)</font> 计算瞬时向量 v 中所有样本数据的十进制对数。特殊情况:

+ ln(+Inf) = +Inf
+ ln(0) = -Inf
+ ln(x < 0) = NaN
+ ln(NaN) = NaN 比如：

```plain
log10(vector(10)) # {} 1
```

## <font style="color:rgb(53, 53, 53);">exp()</font>
<font style="background-color:rgb(241, 243, 245);">exp(v instant-vector)</font> 函数，输入一个瞬时向量，返回各个样本值的 e 的指数值，即 e 的 N 次方。当 N 的值足够大时会返回 +Inf。特殊情况为：

Exp(+Inf) = +Inf

Exp(NaN) = NaN

## <font style="color:rgb(53, 53, 53);">sqrt()</font>
<font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">sqrt(v instant-vector)</font><font style="color:rgb(48, 48, 48);"> 函数计算向量 v 中所有元素的平方根。</font>

## <font style="color:rgb(53, 53, 53);">ceil()</font>
ceil(v instant-vector) 将 v 中所有元素的样本值向上四舍五入到最接近的整数。例如：

```plain
node_load5{instance="192.168.1.75:9100"} # 结果为 2.79ceil(node_load5{instance="192.168.1.75:9100"}) # 结果为 3
```

## <font style="color:rgb(53, 53, 53);">floor()</font>
<font style="background-color:rgb(241, 243, 245);">floor(v instant-vector)</font> 函数与 <font style="background-color:rgb(241, 243, 245);">ceil()</font> 函数相反，将 v 中所有元素的样本值向下四舍五入到最接近的整数。也就是去尾法。

```plain
node_load5{instance="10.23.50.24"} # 结果为 2.65ceil(node_load5{instance="10.23.50.24"}) # 结果为 2
```

## <font style="color:rgb(53, 53, 53);">round()</font>
<font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">round(v instant-vector, to_nearest=1 scalar)</font><font style="color:rgb(48, 48, 48);"> 函数与 </font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">ceil</font><font style="color:rgb(48, 48, 48);"> 和 </font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">floor</font><font style="color:rgb(48, 48, 48);"> 函数类似，返回向量中所有样本值的最接近的整数。</font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">to_nearest</font><font style="color:rgb(48, 48, 48);"> 参数是可选的,默认为 1,表示样本返回的是最接近 1 的整数倍的值。你也可以将该参数指定为任意值（也可以是小数），表示样本返回的是最接近它的整数倍的值。</font>

```plain
round(vector(6.5)) # 7round(vector(6.4)) # 6
```

## <font style="color:rgb(53, 53, 53);">clamp()</font>
<font style="background-color:rgb(241, 243, 245);">clamp(v instant-vector, min scalar, max scalar)</font> 将所有元素的样本值钳制在 v 下限为 min 和上限为 max。

特殊情况： - 返回空向量 if min > max - 返回 NaNifmin 或 maxisNaN

## <font style="color:rgb(53, 53, 53);">clamp_max()</font>
<font style="background-color:rgb(241, 243, 245);">clamp_max(v instant-vector, max scalar)</font> 函数，输入一个瞬时向量和最大值，样本数据值若大于 max，则改为 max，否则不变。例如：

```plain
node_load5{instance="10.32.50.24"} # 结果为 2.79clamp_max(node_load5{instance="10.32.50.24"}, 2) # 结果为 2
```

## <font style="color:rgb(53, 53, 53);">clamp_min()</font>
<font style="background-color:rgb(241, 243, 245);">clamp_min(v instant-vector, min scalar)</font> 函数，输入一个瞬时向量和最小值，样本数据值若小于 min，则改为 min，否则不变。例如：

```plain
node_load5{instance="10.32.50.24"} # 结果为 2.79clamp_min(node_load5{instance="10.32.50.24"}, 3) # 结果为 3
```

# <font style="color:rgb(53, 53, 53);">时间函数</font>
## <font style="color:rgb(53, 53, 53);">minute()</font>
<font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">minute(v=vector(time()) instant-vector)</font><font style="color:rgb(48, 48, 48);"> 函数返回给定 UTC 时间当前小时的第多少分钟。结果范围：0~59。</font>

## <font style="color:rgb(53, 53, 53);">hour()</font>
<font style="background-color:rgb(241, 243, 245);">hour(v=vector(time()) instant-vector)</font> 函数返回被给定 UTC 时间的当前第几个小时，时间范围：0~23。

## <font style="color:rgb(53, 53, 53);">month()</font>
<font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">month(v=vector(time()) instant-vector)</font><font style="color:rgb(48, 48, 48);"> 函数返回给定 UTC 时间当前属于第几个月，结果范围：0~12。</font>

## <font style="color:rgb(53, 53, 53);">year()</font>
<font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">year(v=vector(time()) instant-vector)</font><font style="color:rgb(48, 48, 48);"> 函数返回被给定 UTC 时间的当前年份。</font>

<font style="color:rgb(48, 48, 48);">注意: 即使区间向量内的值分布不均匀，它们在聚合时的权重也是相同的。</font>

<font style="color:rgb(48, 48, 48);">实例演示:</font>

<font style="color:rgb(48, 48, 48);">1.查看进程是哪一年开始运行</font>

```plain
year(process_start_time_seconds) ==>  {instance="localhost:9090", job="Server"} 2021
```

<font style="color:rgb(48, 48, 48);">2.计算本月启动的进程的时间序列</font>

```plain
year(process_start_time_seconds) == bool scalar(year())  * (month(process_start_time_seconds) == bool scalar(month()))==>  {instance="localhost:9090", job="Server"} 1==>  {instance="192.168.1.225:9100", job="linux_exporter"} 0
```

<font style="color:rgb(48, 48, 48);">3.计算本月启动的进程的时间序列个数</font>

```plain
sum(year(process_start_time_seconds) == bool scalar(year())  * (month(process_start_time_seconds) == bool scalar(month())))  
==> {} 1
```

<font style="color:rgb(48, 48, 48);">Tips : 乘法运算符在布尔值使用时就像和运算符一样值 1 表示真，否则为假。</font>

## <font style="color:rgb(53, 53, 53);">day_of_month()</font>
<font style="background-color:rgb(241, 243, 245);">day_of_month(v=vector(time()) instant-vector)</font> 函数，返回被给定 UTC 时间所在月的第几天。返回值范围：1~31。

## <font style="color:rgb(53, 53, 53);">day_of_week()</font>
<font style="background-color:rgb(241, 243, 245);">day_of_week(v=vector(time()) instant-vector)</font>函数，返回被给定 UTC 时间所在周的第几天。返回值范围：0~6，0 表示星期天。

```plain
day_of_week(node_load5{instance="10.32.58.24"})# 值是 4，当前是周六。
```

## <font style="color:rgb(53, 53, 53);">days_in_month()</font>
<font style="background-color:rgb(241, 243, 245);">days_in_month(v=vector(time()) instant-vector)</font> 函数，返回当月一共有多少天。返回值范围：28~31。

```plain
days_in_month(node_load5{instance="10.32.58.24"})# 值是 31 ，因为是 10 月。
```

## <font style="color:rgb(53, 53, 53);">time()</font>
<font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">time()</font><font style="color:rgb(48, 48, 48);"> 函数返回从 1970-01-01 到现在的秒数。注意：它不是直接返回当前时间，而是时间戳</font>

## <font style="color:rgb(53, 53, 53);">timestamp()</font>
<font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">timestamp(v instant-vector)</font><font style="color:rgb(48, 48, 48);"> 函数返回向量 v 中的每个样本的时间戳（从 1970-01-01 到现在的秒数）。  
</font>

<font style="color:rgb(48, 48, 48);">该函数从 Prometheus 2.0 版本开始引入, 与其它时间函数不同的是，它查看瞬时向量中的样本的时间戳而不是值。</font>

<font style="color:rgb(48, 48, 48);">例子 1</font>

```plain
timestamp(vector(time()))  
==> {}   1629783662.714
```

<font style="color:rgb(48, 48, 48);">例子 2，可以看到每个目标的最后异常抓取的开始时间。</font>

```plain
timestamp(up) ==> {instance="localhost:9090", job="Server"} 1629783745.147
```

<font style="color:rgb(48, 48, 48);">例子 3，返回 Prometheus 启动节点导出器抓取时间与节点导出器认为的当前实践的差值。</font>

```plain
node_time_seconds - timestamp(node_time_seconds) ==> {instance="192.168.1.107:9100", job="linux_exporter"} 0.0025420188903808594
```

# <font style="color:rgb(53, 53, 53);">标签函数</font>
## <font style="color:rgb(53, 53, 53);">label_join()</font>
该函数允许你将标签纸连接在用，类似于在重新标记时处理<font style="background-color:rgb(241, 243, 245);">souce_lables</font>方法，同样该函数也不会删除指标名称。

语法格式是 <font style="background-color:rgb(241, 243, 245);">label_join(v instant-vector, dst_label string, separator string, src_label_1 string, src_label_2 string, ...)</font> 。

函数可以将时间序列 v 中多个标签 <font style="background-color:rgb(241, 243, 245);">src_label</font> 的值，通过 <font style="background-color:rgb(241, 243, 245);">separator</font> 作为连接符写入到一个新的标签 <font style="background-color:rgb(241, 243, 245);">dst_label</font> 中。可以有多个 <font style="background-color:rgb(241, 243, 245);">src_label</font> 标签。

例如，以下表达式返回的时间序列多了一个 <font style="background-color:rgb(241, 243, 245);">foo</font> 标签，标签值为<font style="background-color:rgb(241, 243, 245);"> etcd,etcd-k8s</font>：

```plain
up{endpoint="api",instance="192.168.123.248:2379",job="etcd",namespace="monitoring",service="etcd-k8s"}==> up{endpoint="api",instance="192.168.123.248:2379",job="etcd",namespace="monitoring",service="etcd-k8s"} 1 label_join(up{endpoint="api",instance="192.168.123.248:2379",job="etcd",namespace="monitoring",service="etcd-k8s"}, "foo", ",", "job", "service")==> up{endpoint="api",foo="etcd,etcd-k8s",instance="192.168.123.248:2379",job="etcd",namespace="monitoring",service="etcd-k8s"} 1
```

再看一个简单例子：

```plain
go_info{job="LocalServer"}   ==> go_info{instance="localhost:9090", job="LocalServer", version="go1.16.4"} 1
label_join(go_info{job="LocalServer"},"newlable",'|',"job","version")   ==> go_info{instance="localhost:9090", job="LocalServer", newlable="LocalServer|go1.16.4", version="go1.16.4"} 1
```

## <font style="color:rgb(53, 53, 53);">label_replace()</font>
该函数允许你对标签值进行正则表达式替换。与��多数函数不同的是，该函数不会删除指标名称。

为了能够让客户端的图标更具有可读性，可以通过 <font style="background-color:rgb(241, 243, 245);">label_replace</font> 函数为时间序列添加额外的标签。<font style="background-color:rgb(241, 243, 245);">label_replace</font> 的具体参数如下：

```plain
label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)
```

该函数会依次对 v 中的每一条时间序列进行处理，通过 <font style="background-color:rgb(241, 243, 245);">regex</font> 匹配 <font style="background-color:rgb(241, 243, 245);">src_label</font> 的值，并将匹配部分 relacement 写入到 <font style="background-color:rgb(241, 243, 245);">dst_label</font> 标签中。如下所示：

```plain
label_replace(up, "host", "$1", "instance", "(.*):.*")label_replace(up{job="api-server",service="a:c"}, "foo", "$1", "service", "(.*):.*")
```

函数处理后，时间序列将包含一个 <font style="background-color:rgb(241, 243, 245);">host</font> 标签，<font style="background-color:rgb(241, 243, 245);">host</font> 标签的值为 Exporter 实例的 IP 地址：

```plain
up{host="localhost",instance="localhost:8080",job="cadvisor"} 1up{host="localhost",instance="localhost:9090",job="prometheus"} 1up{host="localhost",instance="localhost:9100",job="node"} 1
```

再看一个简单的例子

```plain
up{job="LocalServer"}==> up{instance="localhost:9090", job="LocalServer"}
label_replace(up{job="LocalServer"}, "instance", "$1:9200", "job",  "(.*)")==> up{instance="LocalServer:9200", job="LocalServer"}
```

# <font style="color:rgb(53, 53, 53);">排序函数</font>
## <font style="color:rgb(53, 53, 53);">sort()</font>
<font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">sort(v instant-vector)</font><font style="color:rgb(48, 48, 48);"> 函数对向量按元素的值进行升序排序，返回结果：key: value = 度量指标：样本值[升序排列]  
</font>

<font style="color:rgb(48, 48, 48);">正序</font>

```plain
sort(node_load5{})
```

## <font style="color:rgb(53, 53, 53);">sort_desc()</font>
<font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">sort(v instant-vector)</font><font style="color:rgb(48, 48, 48);"> 函数对向量按元素的值进行降序排序，返回结果：key: value = 度量指标：样本值[降序排列]。</font>

<font style="color:rgb(48, 48, 48);">反序</font>

```plain
sort_desc(node_load5{})
```

# 缺失函数
## <font style="color:rgb(53, 53, 53);">absent()</font>
<font style="background-color:rgb(241, 243, 245);">absent(v instant-vector)</font> 如果传递给它的向量具有任何元素，则返回空向量;如果传递给它的向量没有元素，则返回值为 1 的 1 元素向量。

这这个函数主要用在给定 Metric 名称和 Label 组合不存在时间序列时发出警报或者在页面上展示。

```plain
# 这里提供的向量有样本数据absent(http_requests_total{method="get"})  => no dataabsent(sum(http_requests_total{method="get"}))  => no data
# 由于不存在 Metric nonexistent，所以返回不带 Metric 名称且带有 label 的时间序列，且样本值为1absent(nonexistent{job="myjob"})  => {job="myjob"}  1# 正则匹配的 instance 不作为返回 labels 中的一部分absent(nonexistent{job="myjob",instance=~".*"})  => {job="myjob"}  1
# sum 函数返回的时间序列不带有 label，且没有样本数据absent(sum(nonexistent{job="myjob"}))  => {}  1# 这个时候即使使用 by ，针对 sum 这些聚合函数也不会返回 label。absent(sum(nonexistent{job="myjob"}) by (job))  => {}  1
```

## <font style="color:rgb(53, 53, 53);">histogram_quantile()</font>
<font style="background-color:rgb(241, 243, 245);">histogram_quantile(φ float, b instant-vector)</font> 从 <font style="background-color:rgb(241, 243, 245);">bucket</font> 类型的向量 b 中计算 <font style="background-color:rgb(241, 243, 245);">φ (0 ≤ φ ≤ 1)</font> 分位数（百分位数的一般形式）的样本的最大值。（有关 φ 分位数的详细说明以及直方图指标类型的使用，请参阅直方图和摘要）。向量 b 中的样本是每个 <font style="background-color:rgb(241, 243, 245);">bucket</font> 的采样点数量。每个样本的 <font style="background-color:rgb(241, 243, 245);">labels</font> 中必须要有 <font style="background-color:rgb(241, 243, 245);">le </font>这个 <font style="background-color:rgb(241, 243, 245);">label</font> 来表示每个 <font style="background-color:rgb(241, 243, 245);">bucket</font> 的上边界，没有 <font style="background-color:rgb(241, 243, 245);">le</font> 标签的样本会被忽略。直方图指标类型自动提供带有 <font style="background-color:rgb(241, 243, 245);">_bucket</font> 后缀和相应标签的时间序列。

可以使用 <font style="background-color:rgb(241, 243, 245);">rate()</font> 函数来指定分位数计算的时间窗口。

例如，一个直方图指标名称为 <font style="background-color:rgb(241, 243, 245);">employee_age_bucket_bucket</font>，要计算过去 10 分钟内 第 90 个百分位数，请使用以下表达式：

```plain
histogram_quantile(0.9, rate(employee_age_bucket_bucket[10m]))
```

返回：

```plain
{instance="10.0.86.71:8080",job="prometheus"} 35.714285714285715
```

这表示最近 10 分钟之内 90% 的样本的最大值为 35.714285714285715。

这个计算结果是每组标签组合成一个时间序列。我们可能不会对所有这些维度（如 job、instance 和 method）感兴趣，并希望将其中的一些维度进行聚合，则可以使用 sum() 函数。例如，以下表达式根据 job 标签来对第 90 个百分位数进行聚合：

```plain
# histogram_quantile() 函数必须包含 le 标签histogram_quantile(0.9, sum(rate(employee_age_bucket_bucket[10m])) by (job, le))
```

如果要聚合所有的标签，则使用如下表达式：

```plain
histogram_quantile(0.9,sum(rate(employee_age_bucket_bucket[10m])) by (le))
```

<font style="background-color:rgb(241, 243, 245);">histogram_quantile</font> 这个函数是根据假定每个区间内的样本分布是线性分布来计算结果值的(也就是说它的结果未必准确)，最高的 bucket 必须是 <font style="background-color:rgb(241, 243, 245);">le="+Inf"</font> (否则就返回 NaN)。

如果分位数位于最高的 <font style="background-color:rgb(241, 243, 245);">bucket（+Inf）</font> 中，则返回第二个最高的 bucket 的上边界。如果该 bucket 的上边界大于 0，则假设最低的 bucket 的的下边界为 0，这种情况下在该 bucket 内使用常规的线性插值。

如果分位数位于最低的 bucket 中，则返回最低 bucket 的上边界。

# 计数器函数
## <font style="color:rgb(53, 53, 53);">rate()</font>
<font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">rate(v range-vector)</font><font style="color:rgb(48, 48, 48);"> 函数可以直接计算区间向量 v 在时间窗口内平均增长速率，它会在单调性发生变化时(如由于采样目标重启引起的计数器复位)自动中断。该函数的返回结果不带有度量指标，只有标签列表。</font>

<font style="color:rgb(48, 48, 48);">例如，以下表达式返回区间向量中每个时间序列过去 5 分钟内 HTTP 请求数的每秒增长率：</font>

```plain
rate(http_requests_total[5m])结果：{code="200",handler="label_values",instance="120.77.65.193:9090",job="prometheus",method="get"} 0{code="200",handler="query_range",instance="120.77.65.193:9090",job="prometheus",method="get"} 0{code="200",handler="prometheus",instance="120.77.65.193:9090",job="prometheus",method="get"} 0.2
```

<font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">rate()</font><font style="color:rgb(48, 48, 48);"> 函数返回值类型只能用计数器，在长期趋势分析或者告警中推荐使用这个函数。</font>

<font style="color:rgb(48, 48, 48);">当将 </font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">rate()</font><font style="color:rgb(48, 48, 48);"> 函数与聚合运算符（例如 </font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">sum()</font><font style="color:rgb(48, 48, 48);">）或随时间聚合的函数（任何以 </font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">_over_time</font><font style="color:rgb(48, 48, 48);"> 结尾的函数）一起使用时，必须先执行 </font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">rate()</font><font style="color:rgb(48, 48, 48);"> 函数，然后再进行聚合操作，否则当采样目标重新启动时 </font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">rate()</font><font style="color:rgb(48, 48, 48);"> 无法检测到计数器是否被重置。</font>

## <font style="color:rgb(53, 53, 53);">increase()</font>
<font style="background-color:rgb(241, 243, 245);">increase(v range-vector)</font> 函数获取区间向量中的第一个和最后一个样本并返回其增长量, 它会在单调性发生变化时(如由于采样目标重启引起的计数器复位)自动中断。由于这个值被外推到指定的整个时间范围，所以即使样本值都是整数，你仍然可能会得到一个非整数值。

例如，以下表达式返回区间向量中每个时间序列过去 5 分钟内 HTTP 请求数的增长数：

```plain
increase(http_requests_total{job="apiserver"}[5m])
```

<font style="background-color:rgb(241, 243, 245);">increase</font> 的返回值类型只能是计数器类型，主要作用是增加图表和数据的可读性。使用 <font style="background-color:rgb(241, 243, 245);">rate(v)</font> 函数记录规则的使用率，以便持续跟踪数据样本值的变化。

## <font style="color:rgb(53, 53, 53);">irate()</font>
<font style="background-color:rgb(241, 243, 245);">irate(v range-vector)</font> 函数用于计算区间向量的增长率，但是其反应出的是瞬时增长率。irate 函数是通过区间向量中最后两个两本数据来计算区间向量的增长速率，它会在单调性发生变化时(如由于采样目标重启引起的计数器复位)自动中断。这种方式可以避免在时间窗口范围内的“长尾问题”，并且体现出更好的灵敏度，通过 irate 函数绘制的图标能够更好的反应样本数据的瞬时变化状态。

例如，以下表达式返回区间向量中每个时间序列过去 5 分钟内最后两个样本数据的 HTTP 请求数的增长率：

```plain
irate(http_requests_total{job="api-server"}[5m])
```

<font style="background-color:rgb(241, 243, 245);">irate</font> 只能用于绘制快速变化的计数器，在长期趋势分析或者告警中更推荐使用 rate 函数。因为使用 <font style="background-color:rgb(241, 243, 245);">irate</font> 函数时，速率的简短变化会重置 FOR 语句，形成的图形有很多波峰，难以阅读。

当将 <font style="background-color:rgb(241, 243, 245);">irate() </font>函数与聚合运算符（例如 <font style="background-color:rgb(241, 243, 245);">sum()</font>）或随时间聚合的函数（任何以 <font style="background-color:rgb(241, 243, 245);">_over_time</font> 结尾的函数）一起使用时，必须先执行 <font style="background-color:rgb(241, 243, 245);">irate()</font> 函数，然后再进行聚合操作，否则当采样目标重新启动时 <font style="background-color:rgb(241, 243, 245);">irate()</font> 无法检测到计数器是否被重置。

## <font style="color:rgb(53, 53, 53);">resets()</font>
<font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">resets(v range-vector)</font><font style="color:rgb(48, 48, 48);"> 的参数是一个区间向量。对于每个时间序列，它都返回一个计数器重置的次数。两个连续样本之间的值的减少被认为是一次计数器重置。</font>

<font style="color:rgb(48, 48, 48);">下面我们看一个例子，显示进程的 CPU 时间在过去一个小时重置的次数。</font>

```plain
resets(process_cpu_seconds_total[1h])==> {instance="localhost:9090", job="prom-Server"}  0
```

<font style="color:rgb(48, 48, 48);">这个函数一般只用在计数器类型的时间序列上。</font>

# <font style="color:rgb(53, 53, 53);">Gauge 类型处理函数</font>
## <font style="color:rgb(53, 53, 53);">changes()</font>
对于每个输入时间序列数据，<font style="background-color:rgb(241, 243, 245);">changes(v range-vector)</font> 将返回其值在所提供的时间范围内更改的次数作为即时向量。

```plain
# 如果样本数据值没有发生变化，则返回结果为 0changes(node_load5{instance="10.32.50.24"}[1m]) # 结果为 0
```

## <font style="color:rgb(53, 53, 53);">deriv()</font>
<font style="background-color:rgb(241, 243, 245);">deriv(v range-vector)</font> 的参数是一个区间向量,返回一个瞬时向量。它使用简单的线性回归计算区间向量 v 中各个时间序列的导数。

这个函数一般只用在 Gauge 类型的时间序列上。

```plain
deriv(node_load5[1h])
```

## <font style="color:rgb(53, 53, 53);">predict_linear()</font>
<font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">predict_linear(v range-vector, t scalar)</font><font style="color:rgb(48, 48, 48);"> 函数可以预测时间序列 v 在 t 秒后的值。它基于简单线性回归的方式，对时间窗口内的样本数据进行统计，从而可以对时间序列的变化趋势做出预测。该函数的返回结果不带有度量指标，只有标签列表。  
</font>

<font style="color:rgb(48, 48, 48);">例如，基于 2 小时的样本数据，来预测主机可用磁盘空间的是否在 4 个小时候被占满，可以使用表达式：</font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">predict_linear(node_filesystem_free{job="node"}[2h], 4 * 3600) < 0</font><font style="color:rgb(48, 48, 48);"></font>

<font style="color:rgb(48, 48, 48);">通过下面的例子来观察返回值：</font>

```plain
predict_linear(http_requests_total{code="200",instance="120.77.65.193:9090",job="prometheus",method="get"}[5m], 5)
结果：{code="200",handler="query_range",instance="120.77.65.193:9090",job="prometheus",method="get"} 1{code="200",handler="prometheus",instance="120.77.65.193:9090",job="prometheus",method="get"} 4283.449995397104{code="200",handler="static",instance="120.77.65.193:9090",job="prometheus",method="get"} 22.99999999999999...
```

<font style="color:rgb(48, 48, 48);">例如, 预测四个小时内每个文件系统剩余的可用空间量。</font>

```plain
predict_linear(node_filesystem_free_bytes{instance="192.168.1.107:9100"}[1h],4 * 3600)==>  {device="/dev/mapper/ubuntu--vg-lv--0",fstype="ext4", instance="192.168.1.107:9100", job="linux_exporter", mountpoint="/"}    81532763513.3# 等同于deriv(node_filesystem_free_bytes{instance="192.168.1.107:9100"}[1h] * 4 * 3600) + node_filesystem_free_bytes{instance="192.168.1.107:9100"}[1h]
```

<font style="color:rgb(48, 48, 48);">这个函数一般只用在 </font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">Gauge</font><font style="color:rgb(48, 48, 48);"> 类型的时间序列上。</font>

## <font style="color:rgb(53, 53, 53);">delta()</font>
<font style="background-color:rgb(241, 243, 245);">delta(v range-vector)</font> 的参数是一个区间向量，返回一个瞬时向量。它计算一个区间向量 v 的第一个元素和最后一个元素之间的差值。由于这个值被外推到指定的整个时间范围，所以���使样本值都是整数，你仍然可能会得到一个非整数值。  


例如，下面的例子返回过去一小时的 CPU 5 分钟负载的差：

```plain
delta(node_load5[1h])
```

这个函数一般只用在 Gauge 类型的时间序列上。

## <font style="color:rgb(53, 53, 53);">idelta()</font>
<font style="background-color:rgb(241, 243, 245);">idelta(v range-vector) </font>的参数是一个区间向量, 返回一个瞬时向量。它计算最新的 2 个样本值之间的差值。

这个函数一般只用在 <font style="background-color:rgb(241, 243, 245);">Gauge</font> 类型的时间序列上。

## <font style="color:rgb(53, 53, 53);">holt_winters()</font>
<font style="background-color:rgb(241, 243, 245);">holt_winters(v range-vector, sf scalar, tf scalar)</font> 函数基于区间向量 v，生成时间序列数据平滑值。平滑因子 <font style="background-color:rgb(241, 243, 245);">sf</font> 越低, 对旧数据的重视程度越高。趋势因子 <font style="background-color:rgb(241, 243, 245);">tf</font> 越高，对数据的趋势的考虑就越多。其中，<font style="background-color:rgb(241, 243, 245);">0< sf</font>, <font style="background-color:rgb(241, 243, 245);">tf <=1</font>。

<font style="background-color:rgb(241, 243, 245);">holt_winters</font> 仅适用于 <font style="background-color:rgb(241, 243, 245);">Gauge</font> 类型的时间序列。

# <font style="color:rgb(53, 53, 53);">随时间聚合函数</font>
<font style="color:rgb(48, 48, 48);">下面的函数列表允许传入一个区间向量，它们会聚合每个时间序列的范围，并返回一个瞬时向量：</font>

<font style="color:rgb(48, 48, 48);"></font>

+ <font style="color:rgb(48, 48, 48);">avg_over_time(range-vector) : 区间向量内每个度量指标的平均值。</font>
+ <font style="color:rgb(48, 48, 48);">min_over_time(range-vector) : 区间向量内每个度量指标的最小值。</font>
+ <font style="color:rgb(48, 48, 48);">max_over_time(range-vector) : 区间向量内每个度量指标的最大值。</font>
+ <font style="color:rgb(48, 48, 48);">sum_over_time(range-vector) : 区间向量内每个度量指标的求和。</font>
+ <font style="color:rgb(48, 48, 48);">count_over_time(range-vector) : 区间向量内每个度量指标的样本数据个数。</font>
+ <font style="color:rgb(48, 48, 48);">quantile_over_time(scalar, range-vector) : 区间向量内每个度量指标的样本数据值分位数，φ-quantile (0 ≤ φ ≤ 1)。</font>
+ <font style="color:rgb(48, 48, 48);">stddev_over_time(range-vector) : 区间向量内每个度量指标的总体标准差。</font>
+ <font style="color:rgb(48, 48, 48);">stdvar_over_time(range-vector) : 区间向量内每个度量指标的总体标准方差。</font>

<font style="color:rgb(48, 48, 48);">这些值指定间隔内的所有值在聚合中具有相同的权重，即使这些值在整个间隔内的间隔不相等。</font>

## <font style="color:rgb(53, 53, 53);">absent_over_time()</font>
absent_over_time() 和 absent() 非常类似。

absent_over_time(v range-vector) 如果传递给它的范围向量有任何元素，则返回一个空向量，如果传递给它的范围向量没有元素，则返回一个值为 1 的 1 元素向量。

这对于在给定的指标名称和标签组合在一定时间内不存在时间序列时发出警报非常有用。

```plain
absent_over_time(nonexistent{job="myjob"}[1h])  => {job="myjob"}
absent_over_time(nonexistent{job="myjob",instance=~".*"}[1h])  => {job="myjob"}
absent_over_time(sum(nonexistent{job="myjob"})[1h:])  => {}
```

# 其他函数
## <font style="color:rgb(53, 53, 53);">sgn()</font>
<font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">sgn(v instant-vector)</font><font style="color:rgb(48, 48, 48);"> 返回一个向量，该向量将所有样本值转换为其符号，定义如下:如果 v 是正的，则为 1;如果 v 是负的，则为-1;如果 v 等于 0，则为 0。</font>

## <font style="color:rgb(48, 48, 48);">转为人类可读</font>
<font style="color:rgb(52, 73, 94);background-color:rgb(254, 254, 254);">有些浮点数值位数相当长，非常不便于阅读，此时可以使用如下函数转换为便于人类阅读的数值。</font>

```plain
{{ printf "%.2f" $value }}
或
{{ $value | printf "%.2f" }}
或
{{ $value | humanize }}
```


