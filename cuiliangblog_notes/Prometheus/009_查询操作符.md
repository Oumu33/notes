# 查询操作符
# <font style="color:rgb(53, 53, 53);">二元</font>操作符
## <font style="color:rgb(53, 53, 53);">计算二元操作符</font>
<font style="color:rgb(48, 48, 48);">普罗米修斯中存在以下二进制运算符:</font>

+ <font style="color:rgb(48, 48, 48);">+ (加)</font>
+ <font style="color:rgb(48, 48, 48);">-(减)</font>
+ <font style="color:rgb(48, 48, 48);">*(乘法)</font>
+ <font style="color:rgb(48, 48, 48);">/(除法)</font>
+ <font style="color:rgb(48, 48, 48);">%(取余)</font>
+ <font style="color:rgb(48, 48, 48);">^(取幂)</font>

<font style="color:rgb(48, 48, 48);">二元算术运算符定义在标量/标量、向量/标量和向量/向量值对之间。</font>

<font style="color:rgb(48, 48, 48);">在两个标量之间，行为是明显的，它们计算到另一个标量，该标量是应用于两个标量操作数的操作符的结果。</font>

<font style="color:rgb(48, 48, 48);">在瞬时向量和标量之间，该运算符应用于向量中的每个数据样本的值。例如，如果一个时间序列瞬时向量乘以 2，则结果是另一个向量，其中原始向量的每个样本值都乘以 2。指标名称将被删除。</font>

<font style="color:rgb(48, 48, 48);">在两个瞬时向量之间，对左边向量中的每一项和右边向量中的匹配元素应用一个二元算术运算符。结果被传播到结果向量中，分组标签成为输出标签集。指标名称将被删除。在右边向量中找不到匹配条目的条目不属于结果的一部分。</font>

## <font style="color:rgb(53, 53, 53);">比较二元操作符</font>
<font style="color:rgb(48, 48, 48);">Prometheus 中存在以下二进制比较运算符:</font>

+ <font style="color:rgb(48, 48, 48);">== (等于)</font>
+ <font style="color:rgb(48, 48, 48);">!= (不等于)</font>
+ <font style="color:rgb(48, 48, 48);">> (大于)</font>
+ <font style="color:rgb(48, 48, 48);">< (小于)</font>
+ <font style="color:rgb(48, 48, 48);">>= (大于等于)</font>
+ <font style="color:rgb(48, 48, 48);"><= (小于等于)</font>

<font style="color:rgb(48, 48, 48);">比较运算符定义在标量/标量、向量/标量和向量/向量值对之间。默认情况下，它们进行过滤。它们的行为可以通过在操作符后提供 bool 来修改，这将返回值 0 或 1，而不是过滤。</font>

<font style="color:rgb(48, 48, 48);">在两个标量之间，必须提供 bool 修饰符，这些操作符会产生另一个标量，根据比较结果，标量要么为 0 (false)，要么为 1 (true)</font>

<font style="color:rgb(48, 48, 48);">在瞬时向量和标量之间，这些操作符被应用到向量中的每个数据样本的值，而比较结果为假的向量元素将从结果向量中删除。如果提供了 bool 修饰符，则要删除的向量元素的值为 0，而要保留的向量元素的值为 1。如果提供了 bool 修饰符，则删除指标名称。</font>

<font style="color:rgb(48, 48, 48);">在两个瞬时向量之间，这些操作符默认情况下作为过滤器，应用于匹配的条目。表达式不为真或在表达式的另一端没有找到匹配的向量元素将从结果中删除，而其他元素将传播到结果向量中，分组标签将成为输出标签集。如果提供了 bool 修饰符，那么将被删除的向量元素的值为 0，而将被保留的向量元素的值为 1，分组标签再次成为输出标签集。如果提供了 bool 修饰符，则删除指标名称。</font>

## <font style="color:rgb(53, 53, 53);">逻辑/二元操作符</font>
<font style="color:rgb(48, 48, 48);">这些逻辑/集合二元运算符只在瞬时向量之间定义:</font>

+ <font style="color:rgb(48, 48, 48);">and （与）</font>
+ <font style="color:rgb(48, 48, 48);">or （或）</font>
+ <font style="color:rgb(48, 48, 48);">unless （非）</font>

<font style="color:rgb(48, 48, 48);">Vector1 和 vector2 的结果是一个由 Vector1 中的元素组成的向量，而 vector2 中的元素具有完全匹配的标签集。其他元素被删除。指标名称和值是从左边的向量传递过来的。</font>

<font style="color:rgb(48, 48, 48);">Vector1 或 vector2 的结果是包含 Vector1 的所有原始元素(标签集+值)和 vector2 中没有匹配标签集的所有元素的 vector。</font>

<font style="color:rgb(48, 48, 48);">除非 vector2 的结果是由 Vector1 的元素组成的向量，而在 vector2 中没有完全匹配的标签集。删除两个向量中所有匹配的元素。</font>

## <font style="color:rgb(53, 53, 53);">二元运算符优先级</font>
<font style="color:rgb(48, 48, 48);">下面这个列表列举了 Prometheus 二进制操作符的优先顺序，按照从高到低的顺序排列。</font>

```plain
1. ^2. *, /, %3. +, -4. ==, !=, <=, <, >=, >5. and, unless6. or
```

<font style="color:rgb(48, 48, 48);">相同优先级的操作符是从左向右进行计算的。例如，</font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">2 * 3 % 2</font><font style="color:rgb(48, 48, 48);">相当于</font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">(2 * 3)% 2</font><font style="color:rgb(48, 48, 48);">。但是</font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">^</font><font style="color:rgb(48, 48, 48);">是从右向左的，所以</font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">2 ^ 3 ^ 2</font><font style="color:rgb(48, 48, 48);">等于</font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">2 ^ (3 ^ 2)</font><font style="color:rgb(48, 48, 48);"> 。</font>

# <font style="color:rgb(48, 48, 48);">向量匹配</font>
<font style="color:rgb(48, 48, 48);">向量与向量之间进行运算操作时会基于默认的匹配规则：依次找到与左边向量元素匹配（标签完全一致）的右边向量元素进行运算，如果没找到匹配元素，则直接丢弃。</font>

<font style="color:rgb(48, 48, 48);">接下来将介绍在 PromQL 中有两种典型的匹配模式：一对一（one-to-one）,多对一（many-to-one）或一对多（one-to-many）。</font>

## <font style="color:rgb(53, 53, 53);">一对一向量匹配</font>
<font style="color:rgb(48, 48, 48);">一对一的向量匹配会从操作符的每一边表达式找到一对唯一的样本值。在默认情况下，这是遵循</font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">vector1 <operator> vector2 </font><font style="color:rgb(48, 48, 48);">格式的操作。</font>

<font style="color:rgb(48, 48, 48);">在操作符两边表达式标签不一致的情况下，可以使用 on(label list)或者 ignoring(label list）来修改便签的匹配行为。ignoring 关键字允许在匹配时忽略某些标签，而 on 关键字允许将考虑的标签集减少到提供的列表:</font>

```plain
<vector expr> <bin-op> ignoring(<label list>) <vector expr><vector expr> <bin-op> on(<label list>) <vector expr>
```

<font style="color:rgb(48, 48, 48);">比如这样的数据样本：</font>

```plain
method_code:http_errors:rate5m{method="get", code="500"}  24method_code:http_errors:rate5m{method="get", code="404"}  30method_code:http_errors:rate5m{method="put", code="501"}  3method_code:http_errors:rate5m{method="post", code="500"} 6method_code:http_errors:rate5m{method="post", code="404"} 21
method:http_requests:rate5m{method="get"}  600method:http_requests:rate5m{method="del"}  34method:http_requests:rate5m{method="post"} 120
```

<font style="color:rgb(48, 48, 48);">下面我们看一个查询的例子。</font>

```plain
method_code:http_errors:rate5m{code="500"} / ignoring(code) method:http_requests:rate5m
```

<font style="color:rgb(48, 48, 48);">这该表达式会返回在过去 5 分钟内，HTTP 请求状态码为 500 的在所有请求中的比例。如果没有使用 ignoring(code)，操作符两边表达式返回的瞬时向量中将找不到任何一个标签完全相同的匹配项。</font>

<font style="color:rgb(48, 48, 48);">同时由于 method 为 put 和 del 的样本找不到匹配项，因此不会出现在结果当中。</font>

```plain
{method="get"}  0.04            //  24 / 600{method="post"} 0.05            //   6 / 120
```

## <font style="color:rgb(53, 53, 53);">一对多或者多对一向量匹配</font>
<font style="color:rgb(48, 48, 48);">多对一和一对多匹配是指“一”上的每个向量元素都可以与“多”上的多个元素匹配。这必须使用 </font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">group_left</font><font style="color:rgb(48, 48, 48);"> 或 </font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">group_right</font><font style="color:rgb(48, 48, 48);"> 确定哪一个向量具有更高的基数（充当“多”的角色）。</font>

```plain
<vector expr> <bin-op> ignoring(<label list>) group_left(<label list>) <vector expr><vector expr> <bin-op> ignoring(<label list>) group_right(<label list>) <vector expr><vector expr> <bin-op> on(<label list>) group_left(<label list>) <vector expr><vector expr> <bin-op> on(<label list>) group_right(<label list>) <vector expr>
```

<font style="color:rgb(48, 48, 48);">多对一和一对多两种模式一定是出现在操作符两侧表达式返回的向量标签不一致的情况。因此需要使用 ignoring 和 on 修饰符来排除或者限定匹配的标签列表。</font>

```plain
method_code:http_errors:rate5m / ignoring(code) group_left method:http_requests:rate5m
```

<font style="color:rgb(48, 48, 48);">该表达式中，左向量 method_code:http_errors:rate5m 包含两个标签 method 和 code。而右向量 method:http_requests:rate5m 中只包含一个标签 method，因此匹配时需要使用 ignoring 限定匹配的标签为 code。 在限定匹配标签后，右向量中的元素可能匹配到多个左向量中的元素 因此该表达式的匹配模式为多对一，需要使用 group 修饰符 group_left 指定左向量具有更好的基数。</font>

<font style="color:rgb(48, 48, 48);">最终的运算结果如下：</font>

```plain
{method="get", code="500"}  0.04            //  24 / 600{method="get", code="404"}  0.05            //  30 / 600{method="post", code="500"} 0.05            //   6 / 120{method="post", code="404"} 0.175           //  21 / 120
```

<font style="color:rgb(48, 48, 48);">多对一和一对多匹配是应该仔细考虑的高级用例。通常，正确使用 ignoring(<labels>) 可以得到预期的结果。</font>

# <font style="color:rgb(48, 48, 48);">聚合运算符</font>
<font style="color:rgb(48, 48, 48);">Prometheus 支持以下内置聚合操作符，这些操作符可用于聚合单个瞬时向量的元素，从而生成一个包含更少元素、具有聚合值的新向量:</font>

+ <font style="color:rgb(48, 48, 48);">sum (在当前维度求和)</font>
+ <font style="color:rgb(48, 48, 48);">min (在当前维度取最小值)</font>
+ <font style="color:rgb(48, 48, 48);">max (在当前维度取最大值)</font>
+ <font style="color:rgb(48, 48, 48);">avg (在当前维度计算平均值)</font>
+ <font style="color:rgb(48, 48, 48);">group (结果向量中的所有值都是 1)</font>
+ <font style="color:rgb(48, 48, 48);">stddev (在当前维度计算标准差)</font>
+ <font style="color:rgb(48, 48, 48);">stdvar (在当前维度计算标准方差)</font>
+ <font style="color:rgb(48, 48, 48);">count (计算向量中元素的个数)</font>
+ <font style="color:rgb(48, 48, 48);">count_values (等于某值的元素个数)</font>
+ <font style="color:rgb(48, 48, 48);">bottomk (按样本值计算的最小 k 个元素)</font>
+ <font style="color:rgb(48, 48, 48);">topk (按样本值计算的最大 k 个元素)</font>
+ <font style="color:rgb(48, 48, 48);">quantile (计算φ-quantile(0≤φ≤1)的值，也就是百分位数)</font>

<font style="color:rgb(48, 48, 48);">这些操作符既可以用于对所有标签维度进行聚合，也可以通过包含 without 或 by 子句来保留不同的维度。这些子句可以用在该查询的前面或后面。</font>

```plain
<aggr-op> [without|by (<label list>)] ([parameter,] <vector expression>)
# 或者<aggr-op>([parameter,] <vector expression>) [without|by (<label list>)]
```

<font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">Label list</font><font style="color:rgb(48, 48, 48);">是一个未加引号的标签列表，后面可能包含一个逗号，即(label1, label2)和(label1, label2,)都是有效的语法。</font>

<font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">without</font><font style="color:rgb(48, 48, 48);">删除结果向量中列出的标签，并且保留输出中的其他标签。</font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">by</font><font style="color:rgb(48, 48, 48);">则相反，删除</font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">by</font><font style="color:rgb(48, 48, 48);">子句中没有列出的标签，即使它们的标签值在向量的所有元素中是相同的。</font>

<font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">parameter</font><font style="color:rgb(48, 48, 48);">参数仅用于 count_values、quantile、topk 和 bottomk。</font>

<font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">count_values</font><font style="color:rgb(48, 48, 48);">为每个唯一的样本值输出一个时间序列。每个系列都有一个附加标签。该标签的名称由聚合参数给出，标签值是唯一的样本值。每个时间序列的值是该样本值出现的次数。</font>

<font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">topk</font><font style="color:rgb(48, 48, 48);">和</font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">bottomk</font><font style="color:rgb(48, 48, 48);">与其他聚合器不同的是，在结果向量中返回输入样本的子集(包括原始标签)。</font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">by</font><font style="color:rgb(48, 48, 48);">和</font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">without</font><font style="color:rgb(48, 48, 48);">仅用于抽取输入向量。</font>

<font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">quantile</font><font style="color:rgb(48, 48, 48);">计算</font><font style="color:rgb(48, 48, 48);background-color:rgb(241, 243, 245);">φ-quantile</font><font style="color:rgb(48, 48, 48);">，即在所有维度的 N 个度量值中排名为φ*N 的值。以φ为聚合参数。例如，分位数(0.5，…)计算中位数，分位数(0.95，…)第 95 个百分位。</font>

# <font style="color:rgb(48, 48, 48);">查询示例</font>
## <font style="color:rgb(53, 53, 53);">运算操作符</font>
```plain
#算数操作符+ (加法) - (减法)* (乘法)/ (除法)% (求余)^ (幂运算)
```

上边基本都是常规的运算，幂运算比较少用，我们看一下幂运算

比如下列指标 的值为 5

```plain
process_open_fds
```

我们来求一下 3 次方，也就是 3 次幂 ，最后的结果是 125 。

```plain
process_open_fds ^ 3
```

## <font style="color:rgb(53, 53, 53);">比较运算符</font>
```plain
== (等于)!= (不等于)>  (大于)<  (小于)>= (大于等于)<= (小于等于
```

这些运算符大部分是单独使用，个别情况下可以同时使用，类似大于小于这种情况可以同时使用，枚举一下大约是这么几种情况，其他情况下存在冲突。

```plain
> 、 <
>= 、 <
> 、 <=
```

比如

```plain
process_open_fds > 3 and process_open_fds < 7
```

## <font style="color:rgb(53, 53, 53);">聚合运算符</font>
```plain
sum  #求和min  #最小值max  #最大值avg  #平均值count   #元素个数count_values  #等于某值的元素个数bottomk   #最小的 k 个元素topk      #最大的 k 个元素
```

这些函数适合于这个语法

```plain
<聚合函数>([parameter,] <指标查询语句>) [without|by (<label list>)]
```

<font style="background-color:rgb(241, 243, 245);">without</font>⽤于从计算结果中移除列举的标签，⽽保留其它标签。

<font style="background-color:rgb(241, 243, 245);">by</font> 则正好相反，结果向量中只保留列出的标签，其余标签则移除。

通过<font style="background-color:rgb(241, 243, 245);">without</font>和<font style="background-color:rgb(241, 243, 245);">by</font>可以根据指标的 label 对数据进⾏聚合。

其中只有 count_values , quantile , topk , bottomk ⽀持参数(parameter)。

sum 、max、min、avg 这些都是常见的聚合函数了，我们一起举例就好。

```plain
sum(http_request_total)max(http_request_total)min(http_request_total)avg(http_request_total)
```

对这些指标使用 <font style="background-color:rgb(241, 243, 245);">without</font>和<font style="background-color:rgb(241, 243, 245);">by</font> 就是这样，

```plain
sum(http_request_total) without (instance, job)

sum(http_request_total) by (instance, job)
```

count 是统计指标数值的个数， count_values 是统计含有某个参数或值的数量。

比如

```plain
# 统计文件打开数的值的个数count(process_open_fds)
# 统计 Instance 有多少个值。count_values("instance",process_open_fds)
```

bottomk 和 topk

```plain
# 最小的 5 个值bottomk(5,  process_open_fds)# 最大的 5 个值，Top 5topk(5, process_open_fds)
```


